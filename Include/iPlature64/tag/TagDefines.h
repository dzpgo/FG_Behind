// **********************************************************************
//
// Copyright (c) 2003-2010 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

// Ice version 3.4.1

// <auto-generated>
//
// Generated from file `TagDefines.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#ifndef __tag___TagDefines_h__
#define __tag___TagDefines_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace iPlature
{

typedef ::std::vector< ::Ice::Double> VALUE;

struct CTagObject
{
    ::std::string strName;
    ::Ice::Short nType;
    ::std::string strSource;
    ::std::string strUnit;
    ::std::string strDescription;
    ::Ice::Long nTimeStamp;
    ::std::string strValue;
    ::Ice::Double dCurrent;
    ::Ice::Double dMax;
    ::Ice::Double dMin;
    ::Ice::Double dAverage;
    ::Ice::Double dSum;
    ::Ice::Double dVariance;
    ::Ice::Double dStdDev;
    ::Ice::Int nCalcSample;
    ::Ice::Double dSamStdDev;
    ::iPlature::VALUE dTemp;

    bool operator==(const CTagObject& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(strName != __rhs.strName)
        {
            return false;
        }
        if(nType != __rhs.nType)
        {
            return false;
        }
        if(strSource != __rhs.strSource)
        {
            return false;
        }
        if(strUnit != __rhs.strUnit)
        {
            return false;
        }
        if(strDescription != __rhs.strDescription)
        {
            return false;
        }
        if(nTimeStamp != __rhs.nTimeStamp)
        {
            return false;
        }
        if(strValue != __rhs.strValue)
        {
            return false;
        }
        if(dCurrent != __rhs.dCurrent)
        {
            return false;
        }
        if(dMax != __rhs.dMax)
        {
            return false;
        }
        if(dMin != __rhs.dMin)
        {
            return false;
        }
        if(dAverage != __rhs.dAverage)
        {
            return false;
        }
        if(dSum != __rhs.dSum)
        {
            return false;
        }
        if(dVariance != __rhs.dVariance)
        {
            return false;
        }
        if(dStdDev != __rhs.dStdDev)
        {
            return false;
        }
        if(nCalcSample != __rhs.nCalcSample)
        {
            return false;
        }
        if(dSamStdDev != __rhs.dSamStdDev)
        {
            return false;
        }
        if(dTemp != __rhs.dTemp)
        {
            return false;
        }
        return true;
    }

    bool operator<(const CTagObject& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(strName < __rhs.strName)
        {
            return true;
        }
        else if(__rhs.strName < strName)
        {
            return false;
        }
        if(nType < __rhs.nType)
        {
            return true;
        }
        else if(__rhs.nType < nType)
        {
            return false;
        }
        if(strSource < __rhs.strSource)
        {
            return true;
        }
        else if(__rhs.strSource < strSource)
        {
            return false;
        }
        if(strUnit < __rhs.strUnit)
        {
            return true;
        }
        else if(__rhs.strUnit < strUnit)
        {
            return false;
        }
        if(strDescription < __rhs.strDescription)
        {
            return true;
        }
        else if(__rhs.strDescription < strDescription)
        {
            return false;
        }
        if(nTimeStamp < __rhs.nTimeStamp)
        {
            return true;
        }
        else if(__rhs.nTimeStamp < nTimeStamp)
        {
            return false;
        }
        if(strValue < __rhs.strValue)
        {
            return true;
        }
        else if(__rhs.strValue < strValue)
        {
            return false;
        }
        if(dCurrent < __rhs.dCurrent)
        {
            return true;
        }
        else if(__rhs.dCurrent < dCurrent)
        {
            return false;
        }
        if(dMax < __rhs.dMax)
        {
            return true;
        }
        else if(__rhs.dMax < dMax)
        {
            return false;
        }
        if(dMin < __rhs.dMin)
        {
            return true;
        }
        else if(__rhs.dMin < dMin)
        {
            return false;
        }
        if(dAverage < __rhs.dAverage)
        {
            return true;
        }
        else if(__rhs.dAverage < dAverage)
        {
            return false;
        }
        if(dSum < __rhs.dSum)
        {
            return true;
        }
        else if(__rhs.dSum < dSum)
        {
            return false;
        }
        if(dVariance < __rhs.dVariance)
        {
            return true;
        }
        else if(__rhs.dVariance < dVariance)
        {
            return false;
        }
        if(dStdDev < __rhs.dStdDev)
        {
            return true;
        }
        else if(__rhs.dStdDev < dStdDev)
        {
            return false;
        }
        if(nCalcSample < __rhs.nCalcSample)
        {
            return true;
        }
        else if(__rhs.nCalcSample < nCalcSample)
        {
            return false;
        }
        if(dSamStdDev < __rhs.dSamStdDev)
        {
            return true;
        }
        else if(__rhs.dSamStdDev < dSamStdDev)
        {
            return false;
        }
        if(dTemp < __rhs.dTemp)
        {
            return true;
        }
        else if(__rhs.dTemp < dTemp)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const CTagObject& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const CTagObject& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const CTagObject& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const CTagObject& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct CClockObject
{
    ::std::string strName;
    ::Ice::Int nOffset;
    ::Ice::Int nDelay;

    bool operator==(const CClockObject& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(strName != __rhs.strName)
        {
            return false;
        }
        if(nOffset != __rhs.nOffset)
        {
            return false;
        }
        if(nDelay != __rhs.nDelay)
        {
            return false;
        }
        return true;
    }

    bool operator<(const CClockObject& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(strName < __rhs.strName)
        {
            return true;
        }
        else if(__rhs.strName < strName)
        {
            return false;
        }
        if(nOffset < __rhs.nOffset)
        {
            return true;
        }
        else if(__rhs.nOffset < nOffset)
        {
            return false;
        }
        if(nDelay < __rhs.nDelay)
        {
            return true;
        }
        else if(__rhs.nDelay < nDelay)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const CClockObject& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const CClockObject& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const CClockObject& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const CClockObject& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct CArchiveObject
{
    ::Ice::Int nID;
    ::std::string strName;
    ::Ice::Short nAction;
    ::std::string strClock;
    ::Ice::Int nInterval;
    ::Ice::Short nUsed;

    bool operator==(const CArchiveObject& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(nID != __rhs.nID)
        {
            return false;
        }
        if(strName != __rhs.strName)
        {
            return false;
        }
        if(nAction != __rhs.nAction)
        {
            return false;
        }
        if(strClock != __rhs.strClock)
        {
            return false;
        }
        if(nInterval != __rhs.nInterval)
        {
            return false;
        }
        if(nUsed != __rhs.nUsed)
        {
            return false;
        }
        return true;
    }

    bool operator<(const CArchiveObject& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(nID < __rhs.nID)
        {
            return true;
        }
        else if(__rhs.nID < nID)
        {
            return false;
        }
        if(strName < __rhs.strName)
        {
            return true;
        }
        else if(__rhs.strName < strName)
        {
            return false;
        }
        if(nAction < __rhs.nAction)
        {
            return true;
        }
        else if(__rhs.nAction < nAction)
        {
            return false;
        }
        if(strClock < __rhs.strClock)
        {
            return true;
        }
        else if(__rhs.strClock < strClock)
        {
            return false;
        }
        if(nInterval < __rhs.nInterval)
        {
            return true;
        }
        else if(__rhs.nInterval < nInterval)
        {
            return false;
        }
        if(nUsed < __rhs.nUsed)
        {
            return true;
        }
        else if(__rhs.nUsed < nUsed)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const CArchiveObject& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const CArchiveObject& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const CArchiveObject& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const CArchiveObject& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct CValueObject
{
    ::Ice::Long nTimeStamp;
    ::Ice::Double dValue;

    bool operator==(const CValueObject& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(nTimeStamp != __rhs.nTimeStamp)
        {
            return false;
        }
        if(dValue != __rhs.dValue)
        {
            return false;
        }
        return true;
    }

    bool operator<(const CValueObject& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(nTimeStamp < __rhs.nTimeStamp)
        {
            return true;
        }
        else if(__rhs.nTimeStamp < nTimeStamp)
        {
            return false;
        }
        if(dValue < __rhs.dValue)
        {
            return true;
        }
        else if(__rhs.dValue < dValue)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const CValueObject& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const CValueObject& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const CValueObject& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const CValueObject& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::iPlature::CValueObject> VALUEQUEUE;
void __writeVALUEQUEUE(::IceInternal::BasicStream*, const ::iPlature::CValueObject*, const ::iPlature::CValueObject*);
void __readVALUEQUEUE(::IceInternal::BasicStream*, VALUEQUEUE&);

struct CCacheObject
{
    ::std::string strName;
    ::Ice::Int nPeriod;
    ::iPlature::VALUEQUEUE queueCache;

    bool operator==(const CCacheObject& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(strName != __rhs.strName)
        {
            return false;
        }
        if(nPeriod != __rhs.nPeriod)
        {
            return false;
        }
        if(queueCache != __rhs.queueCache)
        {
            return false;
        }
        return true;
    }

    bool operator<(const CCacheObject& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(strName < __rhs.strName)
        {
            return true;
        }
        else if(__rhs.strName < strName)
        {
            return false;
        }
        if(nPeriod < __rhs.nPeriod)
        {
            return true;
        }
        else if(__rhs.nPeriod < nPeriod)
        {
            return false;
        }
        if(queueCache < __rhs.queueCache)
        {
            return true;
        }
        else if(__rhs.queueCache < queueCache)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const CCacheObject& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const CCacheObject& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const CCacheObject& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const CCacheObject& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

enum LEFTRIGHT
{
    thvLeftOpenRightClose,
    thvLeftOpenRightOpen,
    thvLeftCloseRightOpen,
    thvLeftCloseRightClose
};

void __write(::IceInternal::BasicStream*, LEFTRIGHT);
void __read(::IceInternal::BasicStream*, LEFTRIGHT&);

typedef ::std::vector< ::std::string> TAGNAMEARRAY;

typedef ::std::map< ::std::string, ::std::string> TAGVALUEMAP;
void __writeTAGVALUEMAP(::IceInternal::BasicStream*, const TAGVALUEMAP&);
void __readTAGVALUEMAP(::IceInternal::BasicStream*, TAGVALUEMAP&);

typedef ::std::map< ::std::string, ::iPlature::CTagObject> TAGOBJECTMAP;
void __writeTAGOBJECTMAP(::IceInternal::BasicStream*, const TAGOBJECTMAP&);
void __readTAGOBJECTMAP(::IceInternal::BasicStream*, TAGOBJECTMAP&);

typedef ::std::map< ::std::string, ::iPlature::CClockObject> TAGCLOCKMAP;
void __writeTAGCLOCKMAP(::IceInternal::BasicStream*, const TAGCLOCKMAP&);
void __readTAGCLOCKMAP(::IceInternal::BasicStream*, TAGCLOCKMAP&);

typedef ::std::map< ::Ice::Int, ::iPlature::CArchiveObject> TAGARCHIVEMAP;
void __writeTAGARCHIVEMAP(::IceInternal::BasicStream*, const TAGARCHIVEMAP&);
void __readTAGARCHIVEMAP(::IceInternal::BasicStream*, TAGARCHIVEMAP&);

typedef ::std::map< ::std::string, ::iPlature::CCacheObject> TAGCACHEMAP;
void __writeTAGCACHEMAP(::IceInternal::BasicStream*, const TAGCACHEMAP&);
void __readTAGCACHEMAP(::IceInternal::BasicStream*, TAGCACHEMAP&);

typedef ::std::map< ::Ice::Int, ::iPlature::CCacheObject> TAGDBACTIONMAP;
void __writeTAGDBACTIONMAP(::IceInternal::BasicStream*, const TAGDBACTIONMAP&);
void __readTAGDBACTIONMAP(::IceInternal::BasicStream*, TAGDBACTIONMAP&);

typedef ::std::map< ::std::string, ::iPlature::TAGDBACTIONMAP> TAGHISTORYMAP;
void __writeTAGHISTORYMAP(::IceInternal::BasicStream*, const TAGHISTORYMAP&);
void __readTAGHISTORYMAP(::IceInternal::BasicStream*, TAGHISTORYMAP&);

}

#endif
