// **********************************************************************
//
// Copyright (c) 2003-2010 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

// Ice version 3.4.1

// <auto-generated>
//
// Generated from file `PTInterface.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#ifndef ___________include_clts_slice_PTInterface_h__
#define ___________include_clts_slice_PTInterface_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/StreamF.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace PT
{

class PTInterface;

}

}

namespace PT
{

class PTInterface;
bool operator==(const PTInterface&, const PTInterface&);
bool operator<(const PTInterface&, const PTInterface&);

}

namespace IceInternal
{

::Ice::Object* upCast(::PT::PTInterface*);
::IceProxy::Ice::Object* upCast(::IceProxy::PT::PTInterface*);

}

namespace PT
{

typedef ::IceInternal::Handle< ::PT::PTInterface> PTInterfacePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::PT::PTInterface> PTInterfacePrx;

void __read(::IceInternal::BasicStream*, PTInterfacePrx&);
void __patch__PTInterfacePtr(void*, ::Ice::ObjectPtr&);

}

namespace PT
{

enum InOutMode
{
    INLIB,
    OUTLIB
};

void __write(::IceInternal::BasicStream*, InOutMode);
void __read(::IceInternal::BasicStream*, InOutMode&);

struct TruckCls
{
    ::std::string carNo;
    ::std::string HeadDirection;
    ::std::string TruckPosition;
    ::std::string sqare1;
    ::std::string sqare2;

    bool operator==(const TruckCls& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(carNo != __rhs.carNo)
        {
            return false;
        }
        if(HeadDirection != __rhs.HeadDirection)
        {
            return false;
        }
        if(TruckPosition != __rhs.TruckPosition)
        {
            return false;
        }
        if(sqare1 != __rhs.sqare1)
        {
            return false;
        }
        if(sqare2 != __rhs.sqare2)
        {
            return false;
        }
        return true;
    }

    bool operator<(const TruckCls& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(carNo < __rhs.carNo)
        {
            return true;
        }
        else if(__rhs.carNo < carNo)
        {
            return false;
        }
        if(HeadDirection < __rhs.HeadDirection)
        {
            return true;
        }
        else if(__rhs.HeadDirection < HeadDirection)
        {
            return false;
        }
        if(TruckPosition < __rhs.TruckPosition)
        {
            return true;
        }
        else if(__rhs.TruckPosition < TruckPosition)
        {
            return false;
        }
        if(sqare1 < __rhs.sqare1)
        {
            return true;
        }
        else if(__rhs.sqare1 < sqare1)
        {
            return false;
        }
        if(sqare2 < __rhs.sqare2)
        {
            return true;
        }
        else if(__rhs.sqare2 < sqare2)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const TruckCls& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const TruckCls& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const TruckCls& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const TruckCls& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct dtUnit
{
    ::std::string StoreID;
    ::std::string Location;
    ::std::string BigAreaNO;
    ::std::string UnitNo;
    ::Ice::Int layer;
    ::std::string sqare1;
    ::std::string sqare2;

    bool operator==(const dtUnit& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(StoreID != __rhs.StoreID)
        {
            return false;
        }
        if(Location != __rhs.Location)
        {
            return false;
        }
        if(BigAreaNO != __rhs.BigAreaNO)
        {
            return false;
        }
        if(UnitNo != __rhs.UnitNo)
        {
            return false;
        }
        if(layer != __rhs.layer)
        {
            return false;
        }
        if(sqare1 != __rhs.sqare1)
        {
            return false;
        }
        if(sqare2 != __rhs.sqare2)
        {
            return false;
        }
        return true;
    }

    bool operator<(const dtUnit& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(StoreID < __rhs.StoreID)
        {
            return true;
        }
        else if(__rhs.StoreID < StoreID)
        {
            return false;
        }
        if(Location < __rhs.Location)
        {
            return true;
        }
        else if(__rhs.Location < Location)
        {
            return false;
        }
        if(BigAreaNO < __rhs.BigAreaNO)
        {
            return true;
        }
        else if(__rhs.BigAreaNO < BigAreaNO)
        {
            return false;
        }
        if(UnitNo < __rhs.UnitNo)
        {
            return true;
        }
        else if(__rhs.UnitNo < UnitNo)
        {
            return false;
        }
        if(layer < __rhs.layer)
        {
            return true;
        }
        else if(__rhs.layer < layer)
        {
            return false;
        }
        if(sqare1 < __rhs.sqare1)
        {
            return true;
        }
        else if(__rhs.sqare1 < sqare1)
        {
            return false;
        }
        if(sqare2 < __rhs.sqare2)
        {
            return true;
        }
        else if(__rhs.sqare2 < sqare2)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const dtUnit& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const dtUnit& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const dtUnit& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const dtUnit& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct MatterCls
{
    ::std::string status;
    ::std::string matno;
    ::PT::dtUnit stcUnit;
    ::PT::TruckCls InPosition;
    ::PT::TruckCls OutPosition;
    ::std::string InGroove;
    ::std::string OutGroove;
    bool state;
    ::Ice::Int ackflag;
    ::std::string l3lack;
    ::std::string cQualityCode;
    ::std::string sleeve;
    bool isUnload;
    bool PackageState;
    ::std::string direction;
    ::Ice::Int xPostion;
    ::Ice::Int yPostion;
    ::Ice::Int zPostion;
    ::Ice::Int rowNo;
    ::Ice::Int frameNo;
    ::Ice::Int width;
    ::Ice::Int weight;
    ::std::string shape;
    ::Ice::Int insideDia;
    ::Ice::Int outsideDia;
    ::std::string packCode;
    ::std::string planNo;
    ::std::string MatName;
    ::std::string ManuUnit;
    ::std::string NextUnitno;
    ::std::string ContractNo;
    ::std::string sqare1;
    ::std::string sqare2;

    bool operator==(const MatterCls& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(status != __rhs.status)
        {
            return false;
        }
        if(matno != __rhs.matno)
        {
            return false;
        }
        if(stcUnit != __rhs.stcUnit)
        {
            return false;
        }
        if(InPosition != __rhs.InPosition)
        {
            return false;
        }
        if(OutPosition != __rhs.OutPosition)
        {
            return false;
        }
        if(InGroove != __rhs.InGroove)
        {
            return false;
        }
        if(OutGroove != __rhs.OutGroove)
        {
            return false;
        }
        if(state != __rhs.state)
        {
            return false;
        }
        if(ackflag != __rhs.ackflag)
        {
            return false;
        }
        if(l3lack != __rhs.l3lack)
        {
            return false;
        }
        if(cQualityCode != __rhs.cQualityCode)
        {
            return false;
        }
        if(sleeve != __rhs.sleeve)
        {
            return false;
        }
        if(isUnload != __rhs.isUnload)
        {
            return false;
        }
        if(PackageState != __rhs.PackageState)
        {
            return false;
        }
        if(direction != __rhs.direction)
        {
            return false;
        }
        if(xPostion != __rhs.xPostion)
        {
            return false;
        }
        if(yPostion != __rhs.yPostion)
        {
            return false;
        }
        if(zPostion != __rhs.zPostion)
        {
            return false;
        }
        if(rowNo != __rhs.rowNo)
        {
            return false;
        }
        if(frameNo != __rhs.frameNo)
        {
            return false;
        }
        if(width != __rhs.width)
        {
            return false;
        }
        if(weight != __rhs.weight)
        {
            return false;
        }
        if(shape != __rhs.shape)
        {
            return false;
        }
        if(insideDia != __rhs.insideDia)
        {
            return false;
        }
        if(outsideDia != __rhs.outsideDia)
        {
            return false;
        }
        if(packCode != __rhs.packCode)
        {
            return false;
        }
        if(planNo != __rhs.planNo)
        {
            return false;
        }
        if(MatName != __rhs.MatName)
        {
            return false;
        }
        if(ManuUnit != __rhs.ManuUnit)
        {
            return false;
        }
        if(NextUnitno != __rhs.NextUnitno)
        {
            return false;
        }
        if(ContractNo != __rhs.ContractNo)
        {
            return false;
        }
        if(sqare1 != __rhs.sqare1)
        {
            return false;
        }
        if(sqare2 != __rhs.sqare2)
        {
            return false;
        }
        return true;
    }

    bool operator<(const MatterCls& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(status < __rhs.status)
        {
            return true;
        }
        else if(__rhs.status < status)
        {
            return false;
        }
        if(matno < __rhs.matno)
        {
            return true;
        }
        else if(__rhs.matno < matno)
        {
            return false;
        }
        if(stcUnit < __rhs.stcUnit)
        {
            return true;
        }
        else if(__rhs.stcUnit < stcUnit)
        {
            return false;
        }
        if(InPosition < __rhs.InPosition)
        {
            return true;
        }
        else if(__rhs.InPosition < InPosition)
        {
            return false;
        }
        if(OutPosition < __rhs.OutPosition)
        {
            return true;
        }
        else if(__rhs.OutPosition < OutPosition)
        {
            return false;
        }
        if(InGroove < __rhs.InGroove)
        {
            return true;
        }
        else if(__rhs.InGroove < InGroove)
        {
            return false;
        }
        if(OutGroove < __rhs.OutGroove)
        {
            return true;
        }
        else if(__rhs.OutGroove < OutGroove)
        {
            return false;
        }
        if(state < __rhs.state)
        {
            return true;
        }
        else if(__rhs.state < state)
        {
            return false;
        }
        if(ackflag < __rhs.ackflag)
        {
            return true;
        }
        else if(__rhs.ackflag < ackflag)
        {
            return false;
        }
        if(l3lack < __rhs.l3lack)
        {
            return true;
        }
        else if(__rhs.l3lack < l3lack)
        {
            return false;
        }
        if(cQualityCode < __rhs.cQualityCode)
        {
            return true;
        }
        else if(__rhs.cQualityCode < cQualityCode)
        {
            return false;
        }
        if(sleeve < __rhs.sleeve)
        {
            return true;
        }
        else if(__rhs.sleeve < sleeve)
        {
            return false;
        }
        if(isUnload < __rhs.isUnload)
        {
            return true;
        }
        else if(__rhs.isUnload < isUnload)
        {
            return false;
        }
        if(PackageState < __rhs.PackageState)
        {
            return true;
        }
        else if(__rhs.PackageState < PackageState)
        {
            return false;
        }
        if(direction < __rhs.direction)
        {
            return true;
        }
        else if(__rhs.direction < direction)
        {
            return false;
        }
        if(xPostion < __rhs.xPostion)
        {
            return true;
        }
        else if(__rhs.xPostion < xPostion)
        {
            return false;
        }
        if(yPostion < __rhs.yPostion)
        {
            return true;
        }
        else if(__rhs.yPostion < yPostion)
        {
            return false;
        }
        if(zPostion < __rhs.zPostion)
        {
            return true;
        }
        else if(__rhs.zPostion < zPostion)
        {
            return false;
        }
        if(rowNo < __rhs.rowNo)
        {
            return true;
        }
        else if(__rhs.rowNo < rowNo)
        {
            return false;
        }
        if(frameNo < __rhs.frameNo)
        {
            return true;
        }
        else if(__rhs.frameNo < frameNo)
        {
            return false;
        }
        if(width < __rhs.width)
        {
            return true;
        }
        else if(__rhs.width < width)
        {
            return false;
        }
        if(weight < __rhs.weight)
        {
            return true;
        }
        else if(__rhs.weight < weight)
        {
            return false;
        }
        if(shape < __rhs.shape)
        {
            return true;
        }
        else if(__rhs.shape < shape)
        {
            return false;
        }
        if(insideDia < __rhs.insideDia)
        {
            return true;
        }
        else if(__rhs.insideDia < insideDia)
        {
            return false;
        }
        if(outsideDia < __rhs.outsideDia)
        {
            return true;
        }
        else if(__rhs.outsideDia < outsideDia)
        {
            return false;
        }
        if(packCode < __rhs.packCode)
        {
            return true;
        }
        else if(__rhs.packCode < packCode)
        {
            return false;
        }
        if(planNo < __rhs.planNo)
        {
            return true;
        }
        else if(__rhs.planNo < planNo)
        {
            return false;
        }
        if(MatName < __rhs.MatName)
        {
            return true;
        }
        else if(__rhs.MatName < MatName)
        {
            return false;
        }
        if(ManuUnit < __rhs.ManuUnit)
        {
            return true;
        }
        else if(__rhs.ManuUnit < ManuUnit)
        {
            return false;
        }
        if(NextUnitno < __rhs.NextUnitno)
        {
            return true;
        }
        else if(__rhs.NextUnitno < NextUnitno)
        {
            return false;
        }
        if(ContractNo < __rhs.ContractNo)
        {
            return true;
        }
        else if(__rhs.ContractNo < ContractNo)
        {
            return false;
        }
        if(sqare1 < __rhs.sqare1)
        {
            return true;
        }
        else if(__rhs.sqare1 < sqare1)
        {
            return false;
        }
        if(sqare2 < __rhs.sqare2)
        {
            return true;
        }
        else if(__rhs.sqare2 < sqare2)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const MatterCls& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const MatterCls& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const MatterCls& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const MatterCls& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::PT::MatterCls> MatterClsSeq;
void __writeMatterClsSeq(::IceInternal::BasicStream*, const ::PT::MatterCls*, const ::PT::MatterCls*);
void __readMatterClsSeq(::IceInternal::BasicStream*, MatterClsSeq&);

struct dtPTCommon
{
    ::std::string StoreID;
    ::std::string PTID;
    ::std::string Shift;
    ::std::string Crew;
    ::std::string Operator;
    ::std::string TimeOper;
    ::std::string Privilege;
    ::std::string sqare1;
    ::std::string sqare2;

    bool operator==(const dtPTCommon& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(StoreID != __rhs.StoreID)
        {
            return false;
        }
        if(PTID != __rhs.PTID)
        {
            return false;
        }
        if(Shift != __rhs.Shift)
        {
            return false;
        }
        if(Crew != __rhs.Crew)
        {
            return false;
        }
        if(Operator != __rhs.Operator)
        {
            return false;
        }
        if(TimeOper != __rhs.TimeOper)
        {
            return false;
        }
        if(Privilege != __rhs.Privilege)
        {
            return false;
        }
        if(sqare1 != __rhs.sqare1)
        {
            return false;
        }
        if(sqare2 != __rhs.sqare2)
        {
            return false;
        }
        return true;
    }

    bool operator<(const dtPTCommon& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(StoreID < __rhs.StoreID)
        {
            return true;
        }
        else if(__rhs.StoreID < StoreID)
        {
            return false;
        }
        if(PTID < __rhs.PTID)
        {
            return true;
        }
        else if(__rhs.PTID < PTID)
        {
            return false;
        }
        if(Shift < __rhs.Shift)
        {
            return true;
        }
        else if(__rhs.Shift < Shift)
        {
            return false;
        }
        if(Crew < __rhs.Crew)
        {
            return true;
        }
        else if(__rhs.Crew < Crew)
        {
            return false;
        }
        if(Operator < __rhs.Operator)
        {
            return true;
        }
        else if(__rhs.Operator < Operator)
        {
            return false;
        }
        if(TimeOper < __rhs.TimeOper)
        {
            return true;
        }
        else if(__rhs.TimeOper < TimeOper)
        {
            return false;
        }
        if(Privilege < __rhs.Privilege)
        {
            return true;
        }
        else if(__rhs.Privilege < Privilege)
        {
            return false;
        }
        if(sqare1 < __rhs.sqare1)
        {
            return true;
        }
        else if(__rhs.sqare1 < sqare1)
        {
            return false;
        }
        if(sqare2 < __rhs.sqare2)
        {
            return true;
        }
        else if(__rhs.sqare2 < sqare2)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const dtPTCommon& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const dtPTCommon& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const dtPTCommon& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const dtPTCommon& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct dtOutPlan
{
    bool state;
    ::std::string matterNo;
    ::std::string PlanNO;
    ::PT::dtUnit stcUnit;
    ::std::string LayerNO;
    ::std::string PlanTIME;
    ::std::string ShipCNAME;
    ::std::string OutStoreID;
    ::std::string InStoreID;
    ::std::string MatType;
    ::std::string ShipLotNUM;
    ::std::string HAVEN;
    ::std::string PIECE;
    ::std::string GrossWEIGHT;
    ::std::string NetWEIGHT;
    ::std::string TransTYPE;
    ::std::string FlagStraightFilling;
    ::std::string PlanStatus;
    ::std::string sqare1;
    ::std::string sqare2;

    bool operator==(const dtOutPlan& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(state != __rhs.state)
        {
            return false;
        }
        if(matterNo != __rhs.matterNo)
        {
            return false;
        }
        if(PlanNO != __rhs.PlanNO)
        {
            return false;
        }
        if(stcUnit != __rhs.stcUnit)
        {
            return false;
        }
        if(LayerNO != __rhs.LayerNO)
        {
            return false;
        }
        if(PlanTIME != __rhs.PlanTIME)
        {
            return false;
        }
        if(ShipCNAME != __rhs.ShipCNAME)
        {
            return false;
        }
        if(OutStoreID != __rhs.OutStoreID)
        {
            return false;
        }
        if(InStoreID != __rhs.InStoreID)
        {
            return false;
        }
        if(MatType != __rhs.MatType)
        {
            return false;
        }
        if(ShipLotNUM != __rhs.ShipLotNUM)
        {
            return false;
        }
        if(HAVEN != __rhs.HAVEN)
        {
            return false;
        }
        if(PIECE != __rhs.PIECE)
        {
            return false;
        }
        if(GrossWEIGHT != __rhs.GrossWEIGHT)
        {
            return false;
        }
        if(NetWEIGHT != __rhs.NetWEIGHT)
        {
            return false;
        }
        if(TransTYPE != __rhs.TransTYPE)
        {
            return false;
        }
        if(FlagStraightFilling != __rhs.FlagStraightFilling)
        {
            return false;
        }
        if(PlanStatus != __rhs.PlanStatus)
        {
            return false;
        }
        if(sqare1 != __rhs.sqare1)
        {
            return false;
        }
        if(sqare2 != __rhs.sqare2)
        {
            return false;
        }
        return true;
    }

    bool operator<(const dtOutPlan& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(state < __rhs.state)
        {
            return true;
        }
        else if(__rhs.state < state)
        {
            return false;
        }
        if(matterNo < __rhs.matterNo)
        {
            return true;
        }
        else if(__rhs.matterNo < matterNo)
        {
            return false;
        }
        if(PlanNO < __rhs.PlanNO)
        {
            return true;
        }
        else if(__rhs.PlanNO < PlanNO)
        {
            return false;
        }
        if(stcUnit < __rhs.stcUnit)
        {
            return true;
        }
        else if(__rhs.stcUnit < stcUnit)
        {
            return false;
        }
        if(LayerNO < __rhs.LayerNO)
        {
            return true;
        }
        else if(__rhs.LayerNO < LayerNO)
        {
            return false;
        }
        if(PlanTIME < __rhs.PlanTIME)
        {
            return true;
        }
        else if(__rhs.PlanTIME < PlanTIME)
        {
            return false;
        }
        if(ShipCNAME < __rhs.ShipCNAME)
        {
            return true;
        }
        else if(__rhs.ShipCNAME < ShipCNAME)
        {
            return false;
        }
        if(OutStoreID < __rhs.OutStoreID)
        {
            return true;
        }
        else if(__rhs.OutStoreID < OutStoreID)
        {
            return false;
        }
        if(InStoreID < __rhs.InStoreID)
        {
            return true;
        }
        else if(__rhs.InStoreID < InStoreID)
        {
            return false;
        }
        if(MatType < __rhs.MatType)
        {
            return true;
        }
        else if(__rhs.MatType < MatType)
        {
            return false;
        }
        if(ShipLotNUM < __rhs.ShipLotNUM)
        {
            return true;
        }
        else if(__rhs.ShipLotNUM < ShipLotNUM)
        {
            return false;
        }
        if(HAVEN < __rhs.HAVEN)
        {
            return true;
        }
        else if(__rhs.HAVEN < HAVEN)
        {
            return false;
        }
        if(PIECE < __rhs.PIECE)
        {
            return true;
        }
        else if(__rhs.PIECE < PIECE)
        {
            return false;
        }
        if(GrossWEIGHT < __rhs.GrossWEIGHT)
        {
            return true;
        }
        else if(__rhs.GrossWEIGHT < GrossWEIGHT)
        {
            return false;
        }
        if(NetWEIGHT < __rhs.NetWEIGHT)
        {
            return true;
        }
        else if(__rhs.NetWEIGHT < NetWEIGHT)
        {
            return false;
        }
        if(TransTYPE < __rhs.TransTYPE)
        {
            return true;
        }
        else if(__rhs.TransTYPE < TransTYPE)
        {
            return false;
        }
        if(FlagStraightFilling < __rhs.FlagStraightFilling)
        {
            return true;
        }
        else if(__rhs.FlagStraightFilling < FlagStraightFilling)
        {
            return false;
        }
        if(PlanStatus < __rhs.PlanStatus)
        {
            return true;
        }
        else if(__rhs.PlanStatus < PlanStatus)
        {
            return false;
        }
        if(sqare1 < __rhs.sqare1)
        {
            return true;
        }
        else if(__rhs.sqare1 < sqare1)
        {
            return false;
        }
        if(sqare2 < __rhs.sqare2)
        {
            return true;
        }
        else if(__rhs.sqare2 < sqare2)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const dtOutPlan& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const dtOutPlan& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const dtOutPlan& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const dtOutPlan& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::PT::dtOutPlan> LstOutPlan;
void __writeLstOutPlan(::IceInternal::BasicStream*, const ::PT::dtOutPlan*, const ::PT::dtOutPlan*);
void __readLstOutPlan(::IceInternal::BasicStream*, LstOutPlan&);

struct dtOutPlanMAT
{
    ::std::string PlanNO;
    ::std::string MATNO;
    ::std::string OutMATNO;
    ::std::string LENGTH;
    ::std::string WIDTH;
    ::std::string THICK;
    ::std::string InternalDIAMETER;
    ::std::string ExternalDIAMETER;
    ::std::string NetWEIGHT;
    ::std::string GrossWEIGHT;
    ::PT::dtUnit stcUnit;
    ::std::string LayerNO;
    ::std::string RequireTime;
    ::std::string PlanStatus;
    ::std::string sqare1;
    ::std::string sqare2;

    bool operator==(const dtOutPlanMAT& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(PlanNO != __rhs.PlanNO)
        {
            return false;
        }
        if(MATNO != __rhs.MATNO)
        {
            return false;
        }
        if(OutMATNO != __rhs.OutMATNO)
        {
            return false;
        }
        if(LENGTH != __rhs.LENGTH)
        {
            return false;
        }
        if(WIDTH != __rhs.WIDTH)
        {
            return false;
        }
        if(THICK != __rhs.THICK)
        {
            return false;
        }
        if(InternalDIAMETER != __rhs.InternalDIAMETER)
        {
            return false;
        }
        if(ExternalDIAMETER != __rhs.ExternalDIAMETER)
        {
            return false;
        }
        if(NetWEIGHT != __rhs.NetWEIGHT)
        {
            return false;
        }
        if(GrossWEIGHT != __rhs.GrossWEIGHT)
        {
            return false;
        }
        if(stcUnit != __rhs.stcUnit)
        {
            return false;
        }
        if(LayerNO != __rhs.LayerNO)
        {
            return false;
        }
        if(RequireTime != __rhs.RequireTime)
        {
            return false;
        }
        if(PlanStatus != __rhs.PlanStatus)
        {
            return false;
        }
        if(sqare1 != __rhs.sqare1)
        {
            return false;
        }
        if(sqare2 != __rhs.sqare2)
        {
            return false;
        }
        return true;
    }

    bool operator<(const dtOutPlanMAT& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(PlanNO < __rhs.PlanNO)
        {
            return true;
        }
        else if(__rhs.PlanNO < PlanNO)
        {
            return false;
        }
        if(MATNO < __rhs.MATNO)
        {
            return true;
        }
        else if(__rhs.MATNO < MATNO)
        {
            return false;
        }
        if(OutMATNO < __rhs.OutMATNO)
        {
            return true;
        }
        else if(__rhs.OutMATNO < OutMATNO)
        {
            return false;
        }
        if(LENGTH < __rhs.LENGTH)
        {
            return true;
        }
        else if(__rhs.LENGTH < LENGTH)
        {
            return false;
        }
        if(WIDTH < __rhs.WIDTH)
        {
            return true;
        }
        else if(__rhs.WIDTH < WIDTH)
        {
            return false;
        }
        if(THICK < __rhs.THICK)
        {
            return true;
        }
        else if(__rhs.THICK < THICK)
        {
            return false;
        }
        if(InternalDIAMETER < __rhs.InternalDIAMETER)
        {
            return true;
        }
        else if(__rhs.InternalDIAMETER < InternalDIAMETER)
        {
            return false;
        }
        if(ExternalDIAMETER < __rhs.ExternalDIAMETER)
        {
            return true;
        }
        else if(__rhs.ExternalDIAMETER < ExternalDIAMETER)
        {
            return false;
        }
        if(NetWEIGHT < __rhs.NetWEIGHT)
        {
            return true;
        }
        else if(__rhs.NetWEIGHT < NetWEIGHT)
        {
            return false;
        }
        if(GrossWEIGHT < __rhs.GrossWEIGHT)
        {
            return true;
        }
        else if(__rhs.GrossWEIGHT < GrossWEIGHT)
        {
            return false;
        }
        if(stcUnit < __rhs.stcUnit)
        {
            return true;
        }
        else if(__rhs.stcUnit < stcUnit)
        {
            return false;
        }
        if(LayerNO < __rhs.LayerNO)
        {
            return true;
        }
        else if(__rhs.LayerNO < LayerNO)
        {
            return false;
        }
        if(RequireTime < __rhs.RequireTime)
        {
            return true;
        }
        else if(__rhs.RequireTime < RequireTime)
        {
            return false;
        }
        if(PlanStatus < __rhs.PlanStatus)
        {
            return true;
        }
        else if(__rhs.PlanStatus < PlanStatus)
        {
            return false;
        }
        if(sqare1 < __rhs.sqare1)
        {
            return true;
        }
        else if(__rhs.sqare1 < sqare1)
        {
            return false;
        }
        if(sqare2 < __rhs.sqare2)
        {
            return true;
        }
        else if(__rhs.sqare2 < sqare2)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const dtOutPlanMAT& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const dtOutPlanMAT& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const dtOutPlanMAT& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const dtOutPlanMAT& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::PT::dtOutPlanMAT> LstOutPlanMAT;
void __writeLstOutPlanMAT(::IceInternal::BasicStream*, const ::PT::dtOutPlanMAT*, const ::PT::dtOutPlanMAT*);
void __readLstOutPlanMAT(::IceInternal::BasicStream*, LstOutPlanMAT&);

typedef ::std::vector< ::std::string> LstMATs;

struct inventoryStock
{
    ::std::string select;
    ::std::string unitno;
    ::std::string MATNO;
    ::std::string MATNOFIRST;

    bool operator==(const inventoryStock& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(select != __rhs.select)
        {
            return false;
        }
        if(unitno != __rhs.unitno)
        {
            return false;
        }
        if(MATNO != __rhs.MATNO)
        {
            return false;
        }
        if(MATNOFIRST != __rhs.MATNOFIRST)
        {
            return false;
        }
        return true;
    }

    bool operator<(const inventoryStock& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(select < __rhs.select)
        {
            return true;
        }
        else if(__rhs.select < select)
        {
            return false;
        }
        if(unitno < __rhs.unitno)
        {
            return true;
        }
        else if(__rhs.unitno < unitno)
        {
            return false;
        }
        if(MATNO < __rhs.MATNO)
        {
            return true;
        }
        else if(__rhs.MATNO < MATNO)
        {
            return false;
        }
        if(MATNOFIRST < __rhs.MATNOFIRST)
        {
            return true;
        }
        else if(__rhs.MATNOFIRST < MATNOFIRST)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const inventoryStock& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const inventoryStock& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const inventoryStock& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const inventoryStock& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::PT::inventoryStock> LstInventoryStocks;
void __writeLstInventoryStocks(::IceInternal::BasicStream*, const ::PT::inventoryStock*, const ::PT::inventoryStock*);
void __readLstInventoryStocks(::IceInternal::BasicStream*, LstInventoryStocks&);

}

namespace PT
{

class Callback_PTInterface_UsrLoginCheck_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_UsrLoginCheck_Base> Callback_PTInterface_UsrLoginCheckPtr;

class Callback_PTInterface_TruckPos_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_TruckPos_Base> Callback_PTInterface_TruckPosPtr;

class Callback_PTInterface_TruckInInf_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_TruckInInf_Base> Callback_PTInterface_TruckInInfPtr;

class Callback_PTInterface_SearchMatInf_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_SearchMatInf_Base> Callback_PTInterface_SearchMatInfPtr;

class Callback_PTInterface_DeleteWrongMat_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_DeleteWrongMat_Base> Callback_PTInterface_DeleteWrongMatPtr;

class Callback_PTInterface_SubmitTruckInf_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_SubmitTruckInf_Base> Callback_PTInterface_SubmitTruckInfPtr;

class Callback_PTInterface_TruckInOutAck_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_TruckInOutAck_Base> Callback_PTInterface_TruckInOutAckPtr;

class Callback_PTInterface_PreSend2L3_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_PreSend2L3_Base> Callback_PTInterface_PreSend2L3Ptr;

class Callback_PTInterface_CheckPreSend_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_CheckPreSend_Base> Callback_PTInterface_CheckPreSendPtr;

class Callback_PTInterface_MatInfSearch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_MatInfSearch_Base> Callback_PTInterface_MatInfSearchPtr;

class Callback_PTInterface_MatInfQuery_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_MatInfQuery_Base> Callback_PTInterface_MatInfQueryPtr;

class Callback_PTInterface_StockInfSearch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_StockInfSearch_Base> Callback_PTInterface_StockInfSearchPtr;

class Callback_PTInterface_StockInfSumbit_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_StockInfSumbit_Base> Callback_PTInterface_StockInfSumbitPtr;

class Callback_PTInterface_StockDiffSearch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_StockDiffSearch_Base> Callback_PTInterface_StockDiffSearchPtr;

class Callback_PTInterface_OutSearch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_OutSearch_Base> Callback_PTInterface_OutSearchPtr;

class Callback_PTInterface_OutInventoryInfo_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_OutInventoryInfo_Base> Callback_PTInterface_OutInventoryInfoPtr;

class Callback_PTInterface_RecheckLIST_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_RecheckLIST_Base> Callback_PTInterface_RecheckLISTPtr;

class Callback_PTInterface_MatInOut_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_MatInOut_Base> Callback_PTInterface_MatInOutPtr;

class Callback_PTInterface_MatInOutAckSearch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PTInterface_MatInOutAckSearch_Base> Callback_PTInterface_MatInOutAckSearchPtr;

}

namespace IceProxy
{

namespace PT
{

class PTInterface : virtual public ::IceProxy::Ice::Object
{
public:

    ::Ice::Int UsrLoginCheck(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cPassword, ::std::string& cID, ::Ice::Int& nRet, ::Ice::Int& nResult)
    {
        return UsrLoginCheck(stcPTCommon, cPassword, cID, nRet, nResult, 0);
    }
    ::Ice::Int UsrLoginCheck(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cPassword, ::std::string& cID, ::Ice::Int& nRet, ::Ice::Int& nResult, const ::Ice::Context& __ctx)
    {
        return UsrLoginCheck(stcPTCommon, cPassword, cID, nRet, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_UsrLoginCheck(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cPassword)
    {
        return begin_UsrLoginCheck(stcPTCommon, cPassword, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UsrLoginCheck(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cPassword, const ::Ice::Context& __ctx)
    {
        return begin_UsrLoginCheck(stcPTCommon, cPassword, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UsrLoginCheck(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cPassword, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UsrLoginCheck(stcPTCommon, cPassword, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_UsrLoginCheck(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cPassword, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UsrLoginCheck(stcPTCommon, cPassword, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_UsrLoginCheck(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cPassword, const ::PT::Callback_PTInterface_UsrLoginCheckPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UsrLoginCheck(stcPTCommon, cPassword, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_UsrLoginCheck(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cPassword, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_UsrLoginCheckPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UsrLoginCheck(stcPTCommon, cPassword, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_UsrLoginCheck(::std::string& cID, ::Ice::Int& nRet, ::Ice::Int& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int UsrLoginCheck(const ::PT::dtPTCommon&, const ::std::string&, ::std::string&, ::Ice::Int&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_UsrLoginCheck(const ::PT::dtPTCommon&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int TruckPos(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& truck, ::PT::TruckCls& Turck, ::std::string& cID, ::Ice::Int& nResult)
    {
        return TruckPos(stcPTCommon, truck, Turck, cID, nResult, 0);
    }
    ::Ice::Int TruckPos(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& truck, ::PT::TruckCls& Turck, ::std::string& cID, ::Ice::Int& nResult, const ::Ice::Context& __ctx)
    {
        return TruckPos(stcPTCommon, truck, Turck, cID, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_TruckPos(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& truck)
    {
        return begin_TruckPos(stcPTCommon, truck, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_TruckPos(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& truck, const ::Ice::Context& __ctx)
    {
        return begin_TruckPos(stcPTCommon, truck, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_TruckPos(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& truck, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_TruckPos(stcPTCommon, truck, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_TruckPos(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& truck, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_TruckPos(stcPTCommon, truck, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_TruckPos(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& truck, const ::PT::Callback_PTInterface_TruckPosPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_TruckPos(stcPTCommon, truck, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_TruckPos(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& truck, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_TruckPosPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_TruckPos(stcPTCommon, truck, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_TruckPos(::PT::TruckCls& Turck, ::std::string& cID, ::Ice::Int& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int TruckPos(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::PT::TruckCls&, ::std::string&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_TruckPos(const ::PT::dtPTCommon&, const ::PT::TruckCls&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int TruckInInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo, ::std::string& cID, ::Ice::Int& nResult)
    {
        return TruckInInf(stcPTCommon, CarInf, ProcessNo, cID, nResult, 0);
    }
    ::Ice::Int TruckInInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo, ::std::string& cID, ::Ice::Int& nResult, const ::Ice::Context& __ctx)
    {
        return TruckInInf(stcPTCommon, CarInf, ProcessNo, cID, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_TruckInInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo)
    {
        return begin_TruckInInf(stcPTCommon, CarInf, ProcessNo, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_TruckInInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo, const ::Ice::Context& __ctx)
    {
        return begin_TruckInInf(stcPTCommon, CarInf, ProcessNo, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_TruckInInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_TruckInInf(stcPTCommon, CarInf, ProcessNo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_TruckInInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_TruckInInf(stcPTCommon, CarInf, ProcessNo, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_TruckInInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo, const ::PT::Callback_PTInterface_TruckInInfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_TruckInInf(stcPTCommon, CarInf, ProcessNo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_TruckInInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_TruckInInfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_TruckInInf(stcPTCommon, CarInf, ProcessNo, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_TruckInInf(::std::string& cID, ::Ice::Int& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int TruckInInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, ::std::string&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_TruckInInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int SearchMatInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo, ::PT::MatterClsSeq& matlist, ::std::string& cID, ::Ice::Int& nResult)
    {
        return SearchMatInf(stcPTCommon, CarInf, ProcessNo, matlist, cID, nResult, 0);
    }
    ::Ice::Int SearchMatInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo, ::PT::MatterClsSeq& matlist, ::std::string& cID, ::Ice::Int& nResult, const ::Ice::Context& __ctx)
    {
        return SearchMatInf(stcPTCommon, CarInf, ProcessNo, matlist, cID, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_SearchMatInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo)
    {
        return begin_SearchMatInf(stcPTCommon, CarInf, ProcessNo, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SearchMatInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo, const ::Ice::Context& __ctx)
    {
        return begin_SearchMatInf(stcPTCommon, CarInf, ProcessNo, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SearchMatInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SearchMatInf(stcPTCommon, CarInf, ProcessNo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SearchMatInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SearchMatInf(stcPTCommon, CarInf, ProcessNo, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SearchMatInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo, const ::PT::Callback_PTInterface_SearchMatInfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SearchMatInf(stcPTCommon, CarInf, ProcessNo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SearchMatInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int ProcessNo, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_SearchMatInfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SearchMatInf(stcPTCommon, CarInf, ProcessNo, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_SearchMatInf(::PT::MatterClsSeq& matlist, ::std::string& cID, ::Ice::Int& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int SearchMatInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, ::PT::MatterClsSeq&, ::std::string&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_SearchMatInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int DeleteWrongMat(const ::PT::TruckCls& CarInf, const ::std::string& MATNO, ::Ice::Int ProcessNo, ::Ice::Int& nResult)
    {
        return DeleteWrongMat(CarInf, MATNO, ProcessNo, nResult, 0);
    }
    ::Ice::Int DeleteWrongMat(const ::PT::TruckCls& CarInf, const ::std::string& MATNO, ::Ice::Int ProcessNo, ::Ice::Int& nResult, const ::Ice::Context& __ctx)
    {
        return DeleteWrongMat(CarInf, MATNO, ProcessNo, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_DeleteWrongMat(const ::PT::TruckCls& CarInf, const ::std::string& MATNO, ::Ice::Int ProcessNo)
    {
        return begin_DeleteWrongMat(CarInf, MATNO, ProcessNo, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DeleteWrongMat(const ::PT::TruckCls& CarInf, const ::std::string& MATNO, ::Ice::Int ProcessNo, const ::Ice::Context& __ctx)
    {
        return begin_DeleteWrongMat(CarInf, MATNO, ProcessNo, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DeleteWrongMat(const ::PT::TruckCls& CarInf, const ::std::string& MATNO, ::Ice::Int ProcessNo, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteWrongMat(CarInf, MATNO, ProcessNo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteWrongMat(const ::PT::TruckCls& CarInf, const ::std::string& MATNO, ::Ice::Int ProcessNo, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteWrongMat(CarInf, MATNO, ProcessNo, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteWrongMat(const ::PT::TruckCls& CarInf, const ::std::string& MATNO, ::Ice::Int ProcessNo, const ::PT::Callback_PTInterface_DeleteWrongMatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteWrongMat(CarInf, MATNO, ProcessNo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteWrongMat(const ::PT::TruckCls& CarInf, const ::std::string& MATNO, ::Ice::Int ProcessNo, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_DeleteWrongMatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteWrongMat(CarInf, MATNO, ProcessNo, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_DeleteWrongMat(::Ice::Int& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int DeleteWrongMat(const ::PT::TruckCls&, const ::std::string&, ::Ice::Int, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_DeleteWrongMat(const ::PT::TruckCls&, const ::std::string&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int SubmitTruckInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int WorkType, const ::PT::MatterClsSeq& matlist, ::Ice::Int& nResult)
    {
        return SubmitTruckInf(stcPTCommon, CarInf, WorkType, matlist, nResult, 0);
    }
    ::Ice::Int SubmitTruckInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int WorkType, const ::PT::MatterClsSeq& matlist, ::Ice::Int& nResult, const ::Ice::Context& __ctx)
    {
        return SubmitTruckInf(stcPTCommon, CarInf, WorkType, matlist, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_SubmitTruckInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int WorkType, const ::PT::MatterClsSeq& matlist)
    {
        return begin_SubmitTruckInf(stcPTCommon, CarInf, WorkType, matlist, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SubmitTruckInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int WorkType, const ::PT::MatterClsSeq& matlist, const ::Ice::Context& __ctx)
    {
        return begin_SubmitTruckInf(stcPTCommon, CarInf, WorkType, matlist, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SubmitTruckInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int WorkType, const ::PT::MatterClsSeq& matlist, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SubmitTruckInf(stcPTCommon, CarInf, WorkType, matlist, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SubmitTruckInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int WorkType, const ::PT::MatterClsSeq& matlist, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SubmitTruckInf(stcPTCommon, CarInf, WorkType, matlist, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SubmitTruckInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int WorkType, const ::PT::MatterClsSeq& matlist, const ::PT::Callback_PTInterface_SubmitTruckInfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SubmitTruckInf(stcPTCommon, CarInf, WorkType, matlist, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SubmitTruckInf(const ::PT::dtPTCommon& stcPTCommon, const ::PT::TruckCls& CarInf, ::Ice::Int WorkType, const ::PT::MatterClsSeq& matlist, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_SubmitTruckInfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SubmitTruckInf(stcPTCommon, CarInf, WorkType, matlist, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_SubmitTruckInf(::Ice::Int& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int SubmitTruckInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_SubmitTruckInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, const ::PT::MatterClsSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int TruckInOutAck(const ::PT::dtPTCommon& stcPTCommon, ::Ice::Int ProcessNo, ::Ice::Int& nResult, ::PT::MatterClsSeq& matlist)
    {
        return TruckInOutAck(stcPTCommon, ProcessNo, nResult, matlist, 0);
    }
    ::Ice::Int TruckInOutAck(const ::PT::dtPTCommon& stcPTCommon, ::Ice::Int ProcessNo, ::Ice::Int& nResult, ::PT::MatterClsSeq& matlist, const ::Ice::Context& __ctx)
    {
        return TruckInOutAck(stcPTCommon, ProcessNo, nResult, matlist, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_TruckInOutAck(const ::PT::dtPTCommon& stcPTCommon, ::Ice::Int ProcessNo)
    {
        return begin_TruckInOutAck(stcPTCommon, ProcessNo, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_TruckInOutAck(const ::PT::dtPTCommon& stcPTCommon, ::Ice::Int ProcessNo, const ::Ice::Context& __ctx)
    {
        return begin_TruckInOutAck(stcPTCommon, ProcessNo, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_TruckInOutAck(const ::PT::dtPTCommon& stcPTCommon, ::Ice::Int ProcessNo, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_TruckInOutAck(stcPTCommon, ProcessNo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_TruckInOutAck(const ::PT::dtPTCommon& stcPTCommon, ::Ice::Int ProcessNo, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_TruckInOutAck(stcPTCommon, ProcessNo, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_TruckInOutAck(const ::PT::dtPTCommon& stcPTCommon, ::Ice::Int ProcessNo, const ::PT::Callback_PTInterface_TruckInOutAckPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_TruckInOutAck(stcPTCommon, ProcessNo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_TruckInOutAck(const ::PT::dtPTCommon& stcPTCommon, ::Ice::Int ProcessNo, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_TruckInOutAckPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_TruckInOutAck(stcPTCommon, ProcessNo, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_TruckInOutAck(::Ice::Int& nResult, ::PT::MatterClsSeq& matlist, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int TruckInOutAck(const ::PT::dtPTCommon&, ::Ice::Int, ::Ice::Int&, ::PT::MatterClsSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_TruckInOutAck(const ::PT::dtPTCommon&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int PreSend2L3(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::std::string& MT, const ::std::string& cPresend, ::std::string& cID, ::Ice::Int& nResult)
    {
        return PreSend2L3(stcPTCommon, cMAT, MT, cPresend, cID, nResult, 0);
    }
    ::Ice::Int PreSend2L3(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::std::string& MT, const ::std::string& cPresend, ::std::string& cID, ::Ice::Int& nResult, const ::Ice::Context& __ctx)
    {
        return PreSend2L3(stcPTCommon, cMAT, MT, cPresend, cID, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_PreSend2L3(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::std::string& MT, const ::std::string& cPresend)
    {
        return begin_PreSend2L3(stcPTCommon, cMAT, MT, cPresend, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PreSend2L3(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::std::string& MT, const ::std::string& cPresend, const ::Ice::Context& __ctx)
    {
        return begin_PreSend2L3(stcPTCommon, cMAT, MT, cPresend, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PreSend2L3(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::std::string& MT, const ::std::string& cPresend, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PreSend2L3(stcPTCommon, cMAT, MT, cPresend, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_PreSend2L3(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::std::string& MT, const ::std::string& cPresend, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PreSend2L3(stcPTCommon, cMAT, MT, cPresend, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_PreSend2L3(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::std::string& MT, const ::std::string& cPresend, const ::PT::Callback_PTInterface_PreSend2L3Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PreSend2L3(stcPTCommon, cMAT, MT, cPresend, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_PreSend2L3(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::std::string& MT, const ::std::string& cPresend, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_PreSend2L3Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_PreSend2L3(stcPTCommon, cMAT, MT, cPresend, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_PreSend2L3(::std::string& cID, ::Ice::Int& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int PreSend2L3(const ::PT::dtPTCommon&, const ::std::string&, const ::std::string&, const ::std::string&, ::std::string&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_PreSend2L3(const ::PT::dtPTCommon&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int CheckPreSend(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, ::std::string& cRetMessage, ::Ice::Int& nResult)
    {
        return CheckPreSend(stcPTCommon, cMAT, cRetMessage, nResult, 0);
    }
    ::Ice::Int CheckPreSend(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, ::std::string& cRetMessage, ::Ice::Int& nResult, const ::Ice::Context& __ctx)
    {
        return CheckPreSend(stcPTCommon, cMAT, cRetMessage, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_CheckPreSend(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT)
    {
        return begin_CheckPreSend(stcPTCommon, cMAT, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CheckPreSend(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::Ice::Context& __ctx)
    {
        return begin_CheckPreSend(stcPTCommon, cMAT, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CheckPreSend(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CheckPreSend(stcPTCommon, cMAT, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CheckPreSend(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CheckPreSend(stcPTCommon, cMAT, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CheckPreSend(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::PT::Callback_PTInterface_CheckPreSendPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CheckPreSend(stcPTCommon, cMAT, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CheckPreSend(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_CheckPreSendPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CheckPreSend(stcPTCommon, cMAT, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_CheckPreSend(::std::string& cRetMessage, ::Ice::Int& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int CheckPreSend(const ::PT::dtPTCommon&, const ::std::string&, ::std::string&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_CheckPreSend(const ::PT::dtPTCommon&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int MatInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, ::PT::MatterCls& mat, ::Ice::Int& nResult)
    {
        return MatInfSearch(stcPTCommon, cMAT, mat, nResult, 0);
    }
    ::Ice::Int MatInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, ::PT::MatterCls& mat, ::Ice::Int& nResult, const ::Ice::Context& __ctx)
    {
        return MatInfSearch(stcPTCommon, cMAT, mat, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_MatInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT)
    {
        return begin_MatInfSearch(stcPTCommon, cMAT, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_MatInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::Ice::Context& __ctx)
    {
        return begin_MatInfSearch(stcPTCommon, cMAT, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_MatInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInfSearch(stcPTCommon, cMAT, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_MatInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInfSearch(stcPTCommon, cMAT, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_MatInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::PT::Callback_PTInterface_MatInfSearchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInfSearch(stcPTCommon, cMAT, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_MatInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& cMAT, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_MatInfSearchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInfSearch(stcPTCommon, cMAT, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_MatInfSearch(::PT::MatterCls& mat, ::Ice::Int& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int MatInfSearch(const ::PT::dtPTCommon&, const ::std::string&, ::PT::MatterCls&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_MatInfSearch(const ::PT::dtPTCommon&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int MatInfQuery(const ::std::string& cMAT, ::Ice::Int& nResult)
    {
        return MatInfQuery(cMAT, nResult, 0);
    }
    ::Ice::Int MatInfQuery(const ::std::string& cMAT, ::Ice::Int& nResult, const ::Ice::Context& __ctx)
    {
        return MatInfQuery(cMAT, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_MatInfQuery(const ::std::string& cMAT)
    {
        return begin_MatInfQuery(cMAT, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_MatInfQuery(const ::std::string& cMAT, const ::Ice::Context& __ctx)
    {
        return begin_MatInfQuery(cMAT, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_MatInfQuery(const ::std::string& cMAT, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInfQuery(cMAT, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_MatInfQuery(const ::std::string& cMAT, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInfQuery(cMAT, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_MatInfQuery(const ::std::string& cMAT, const ::PT::Callback_PTInterface_MatInfQueryPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInfQuery(cMAT, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_MatInfQuery(const ::std::string& cMAT, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_MatInfQueryPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInfQuery(cMAT, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_MatInfQuery(::Ice::Int& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int MatInfQuery(const ::std::string&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_MatInfQuery(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int StockInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& ColNo, ::PT::MatterClsSeq& mat, ::Ice::Int& nResult)
    {
        return StockInfSearch(stcPTCommon, ColNo, mat, nResult, 0);
    }
    ::Ice::Int StockInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& ColNo, ::PT::MatterClsSeq& mat, ::Ice::Int& nResult, const ::Ice::Context& __ctx)
    {
        return StockInfSearch(stcPTCommon, ColNo, mat, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_StockInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& ColNo)
    {
        return begin_StockInfSearch(stcPTCommon, ColNo, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StockInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& ColNo, const ::Ice::Context& __ctx)
    {
        return begin_StockInfSearch(stcPTCommon, ColNo, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StockInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& ColNo, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StockInfSearch(stcPTCommon, ColNo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StockInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& ColNo, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StockInfSearch(stcPTCommon, ColNo, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StockInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& ColNo, const ::PT::Callback_PTInterface_StockInfSearchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StockInfSearch(stcPTCommon, ColNo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StockInfSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& ColNo, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_StockInfSearchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StockInfSearch(stcPTCommon, ColNo, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_StockInfSearch(::PT::MatterClsSeq& mat, ::Ice::Int& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int StockInfSearch(const ::PT::dtPTCommon&, const ::std::string&, ::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_StockInfSearch(const ::PT::dtPTCommon&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int StockInfSumbit(const ::std::string& type, const ::PT::dtPTCommon& stcPTCommon, const ::PT::MatterClsSeq& mat, ::Ice::Int& nResult)
    {
        return StockInfSumbit(type, stcPTCommon, mat, nResult, 0);
    }
    ::Ice::Int StockInfSumbit(const ::std::string& type, const ::PT::dtPTCommon& stcPTCommon, const ::PT::MatterClsSeq& mat, ::Ice::Int& nResult, const ::Ice::Context& __ctx)
    {
        return StockInfSumbit(type, stcPTCommon, mat, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_StockInfSumbit(const ::std::string& type, const ::PT::dtPTCommon& stcPTCommon, const ::PT::MatterClsSeq& mat)
    {
        return begin_StockInfSumbit(type, stcPTCommon, mat, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StockInfSumbit(const ::std::string& type, const ::PT::dtPTCommon& stcPTCommon, const ::PT::MatterClsSeq& mat, const ::Ice::Context& __ctx)
    {
        return begin_StockInfSumbit(type, stcPTCommon, mat, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StockInfSumbit(const ::std::string& type, const ::PT::dtPTCommon& stcPTCommon, const ::PT::MatterClsSeq& mat, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StockInfSumbit(type, stcPTCommon, mat, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StockInfSumbit(const ::std::string& type, const ::PT::dtPTCommon& stcPTCommon, const ::PT::MatterClsSeq& mat, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StockInfSumbit(type, stcPTCommon, mat, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StockInfSumbit(const ::std::string& type, const ::PT::dtPTCommon& stcPTCommon, const ::PT::MatterClsSeq& mat, const ::PT::Callback_PTInterface_StockInfSumbitPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StockInfSumbit(type, stcPTCommon, mat, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StockInfSumbit(const ::std::string& type, const ::PT::dtPTCommon& stcPTCommon, const ::PT::MatterClsSeq& mat, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_StockInfSumbitPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StockInfSumbit(type, stcPTCommon, mat, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_StockInfSumbit(::Ice::Int& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int StockInfSumbit(const ::std::string&, const ::PT::dtPTCommon&, const ::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_StockInfSumbit(const ::std::string&, const ::PT::dtPTCommon&, const ::PT::MatterClsSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int StockDiffSearch(::PT::MatterClsSeq& mat, ::Ice::Int& nResult)
    {
        return StockDiffSearch(mat, nResult, 0);
    }
    ::Ice::Int StockDiffSearch(::PT::MatterClsSeq& mat, ::Ice::Int& nResult, const ::Ice::Context& __ctx)
    {
        return StockDiffSearch(mat, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_StockDiffSearch()
    {
        return begin_StockDiffSearch(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StockDiffSearch(const ::Ice::Context& __ctx)
    {
        return begin_StockDiffSearch(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StockDiffSearch(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StockDiffSearch(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StockDiffSearch(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StockDiffSearch(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StockDiffSearch(const ::PT::Callback_PTInterface_StockDiffSearchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StockDiffSearch(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StockDiffSearch(const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_StockDiffSearchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StockDiffSearch(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_StockDiffSearch(::PT::MatterClsSeq& mat, ::Ice::Int& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int StockDiffSearch(::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_StockDiffSearch(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int OutSearch(const ::std::string& type, ::PT::LstOutPlan& matlist, ::Ice::Int& nResult)
    {
        return OutSearch(type, matlist, nResult, 0);
    }
    ::Ice::Int OutSearch(const ::std::string& type, ::PT::LstOutPlan& matlist, ::Ice::Int& nResult, const ::Ice::Context& __ctx)
    {
        return OutSearch(type, matlist, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_OutSearch(const ::std::string& type)
    {
        return begin_OutSearch(type, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_OutSearch(const ::std::string& type, const ::Ice::Context& __ctx)
    {
        return begin_OutSearch(type, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_OutSearch(const ::std::string& type, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_OutSearch(type, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_OutSearch(const ::std::string& type, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_OutSearch(type, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_OutSearch(const ::std::string& type, const ::PT::Callback_PTInterface_OutSearchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_OutSearch(type, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_OutSearch(const ::std::string& type, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_OutSearchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_OutSearch(type, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_OutSearch(::PT::LstOutPlan& matlist, ::Ice::Int& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int OutSearch(const ::std::string&, ::PT::LstOutPlan&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_OutSearch(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int OutInventoryInfo(const ::std::string& bayno, ::std::string& id, ::std::string& area)
    {
        return OutInventoryInfo(bayno, id, area, 0);
    }
    ::Ice::Int OutInventoryInfo(const ::std::string& bayno, ::std::string& id, ::std::string& area, const ::Ice::Context& __ctx)
    {
        return OutInventoryInfo(bayno, id, area, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_OutInventoryInfo(const ::std::string& bayno)
    {
        return begin_OutInventoryInfo(bayno, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_OutInventoryInfo(const ::std::string& bayno, const ::Ice::Context& __ctx)
    {
        return begin_OutInventoryInfo(bayno, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_OutInventoryInfo(const ::std::string& bayno, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_OutInventoryInfo(bayno, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_OutInventoryInfo(const ::std::string& bayno, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_OutInventoryInfo(bayno, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_OutInventoryInfo(const ::std::string& bayno, const ::PT::Callback_PTInterface_OutInventoryInfoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_OutInventoryInfo(bayno, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_OutInventoryInfo(const ::std::string& bayno, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_OutInventoryInfoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_OutInventoryInfo(bayno, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_OutInventoryInfo(::std::string& id, ::std::string& area, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int OutInventoryInfo(const ::std::string&, ::std::string&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_OutInventoryInfo(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int RecheckLIST(const ::std::string& bayno, ::std::string& id, ::PT::LstInventoryStocks& LIST)
    {
        return RecheckLIST(bayno, id, LIST, 0);
    }
    ::Ice::Int RecheckLIST(const ::std::string& bayno, ::std::string& id, ::PT::LstInventoryStocks& LIST, const ::Ice::Context& __ctx)
    {
        return RecheckLIST(bayno, id, LIST, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_RecheckLIST(const ::std::string& bayno)
    {
        return begin_RecheckLIST(bayno, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RecheckLIST(const ::std::string& bayno, const ::Ice::Context& __ctx)
    {
        return begin_RecheckLIST(bayno, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RecheckLIST(const ::std::string& bayno, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_RecheckLIST(bayno, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_RecheckLIST(const ::std::string& bayno, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_RecheckLIST(bayno, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_RecheckLIST(const ::std::string& bayno, const ::PT::Callback_PTInterface_RecheckLISTPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_RecheckLIST(bayno, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_RecheckLIST(const ::std::string& bayno, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_RecheckLISTPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_RecheckLIST(bayno, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_RecheckLIST(::std::string& id, ::PT::LstInventoryStocks& LIST, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int RecheckLIST(const ::std::string&, ::std::string&, ::PT::LstInventoryStocks&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_RecheckLIST(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int MatInOut(const ::std::string& type, const ::std::string& tagValue, ::std::string& nResult)
    {
        return MatInOut(type, tagValue, nResult, 0);
    }
    ::Ice::Int MatInOut(const ::std::string& type, const ::std::string& tagValue, ::std::string& nResult, const ::Ice::Context& __ctx)
    {
        return MatInOut(type, tagValue, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_MatInOut(const ::std::string& type, const ::std::string& tagValue)
    {
        return begin_MatInOut(type, tagValue, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_MatInOut(const ::std::string& type, const ::std::string& tagValue, const ::Ice::Context& __ctx)
    {
        return begin_MatInOut(type, tagValue, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_MatInOut(const ::std::string& type, const ::std::string& tagValue, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInOut(type, tagValue, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_MatInOut(const ::std::string& type, const ::std::string& tagValue, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInOut(type, tagValue, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_MatInOut(const ::std::string& type, const ::std::string& tagValue, const ::PT::Callback_PTInterface_MatInOutPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInOut(type, tagValue, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_MatInOut(const ::std::string& type, const ::std::string& tagValue, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_MatInOutPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInOut(type, tagValue, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_MatInOut(::std::string& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int MatInOut(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_MatInOut(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int MatInOutAckSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& matno, const ::std::string& type, ::std::string& nResult)
    {
        return MatInOutAckSearch(stcPTCommon, matno, type, nResult, 0);
    }
    ::Ice::Int MatInOutAckSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& matno, const ::std::string& type, ::std::string& nResult, const ::Ice::Context& __ctx)
    {
        return MatInOutAckSearch(stcPTCommon, matno, type, nResult, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_MatInOutAckSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& matno, const ::std::string& type)
    {
        return begin_MatInOutAckSearch(stcPTCommon, matno, type, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_MatInOutAckSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& matno, const ::std::string& type, const ::Ice::Context& __ctx)
    {
        return begin_MatInOutAckSearch(stcPTCommon, matno, type, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_MatInOutAckSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& matno, const ::std::string& type, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInOutAckSearch(stcPTCommon, matno, type, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_MatInOutAckSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& matno, const ::std::string& type, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInOutAckSearch(stcPTCommon, matno, type, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_MatInOutAckSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& matno, const ::std::string& type, const ::PT::Callback_PTInterface_MatInOutAckSearchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInOutAckSearch(stcPTCommon, matno, type, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_MatInOutAckSearch(const ::PT::dtPTCommon& stcPTCommon, const ::std::string& matno, const ::std::string& type, const ::Ice::Context& __ctx, const ::PT::Callback_PTInterface_MatInOutAckSearchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_MatInOutAckSearch(stcPTCommon, matno, type, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_MatInOutAckSearch(::std::string& nResult, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int MatInOutAckSearch(const ::PT::dtPTCommon&, const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_MatInOutAckSearch(const ::PT::dtPTCommon&, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<PTInterface> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PTInterface> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PTInterface*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<PTInterface*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace PT
{

class PTInterface : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::Ice::Int UsrLoginCheck(const ::PT::dtPTCommon&, const ::std::string&, ::std::string&, ::Ice::Int&, ::Ice::Int&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int TruckPos(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::PT::TruckCls&, ::std::string&, ::Ice::Int&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int TruckInInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, ::std::string&, ::Ice::Int&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int SearchMatInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, ::PT::MatterClsSeq&, ::std::string&, ::Ice::Int&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int DeleteWrongMat(const ::PT::TruckCls&, const ::std::string&, ::Ice::Int, ::Ice::Int&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int SubmitTruckInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int TruckInOutAck(const ::PT::dtPTCommon&, ::Ice::Int, ::Ice::Int&, ::PT::MatterClsSeq&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int PreSend2L3(const ::PT::dtPTCommon&, const ::std::string&, const ::std::string&, const ::std::string&, ::std::string&, ::Ice::Int&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int CheckPreSend(const ::PT::dtPTCommon&, const ::std::string&, ::std::string&, ::Ice::Int&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int MatInfSearch(const ::PT::dtPTCommon&, const ::std::string&, ::PT::MatterCls&, ::Ice::Int&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int MatInfQuery(const ::std::string&, ::Ice::Int&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int StockInfSearch(const ::PT::dtPTCommon&, const ::std::string&, ::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int StockInfSumbit(const ::std::string&, const ::PT::dtPTCommon&, const ::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int StockDiffSearch(::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int OutSearch(const ::std::string&, ::PT::LstOutPlan&, ::Ice::Int&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int OutInventoryInfo(const ::std::string&, ::std::string&, ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int RecheckLIST(const ::std::string&, ::std::string&, ::PT::LstInventoryStocks&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int MatInOut(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int MatInOutAckSearch(const ::PT::dtPTCommon&, const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*) = 0;
};

}

}

namespace IceDelegateM
{

namespace PT
{

class PTInterface : virtual public ::IceDelegate::PT::PTInterface,
                    virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::Ice::Int UsrLoginCheck(const ::PT::dtPTCommon&, const ::std::string&, ::std::string&, ::Ice::Int&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int TruckPos(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::PT::TruckCls&, ::std::string&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int TruckInInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, ::std::string&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int SearchMatInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, ::PT::MatterClsSeq&, ::std::string&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int DeleteWrongMat(const ::PT::TruckCls&, const ::std::string&, ::Ice::Int, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int SubmitTruckInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int TruckInOutAck(const ::PT::dtPTCommon&, ::Ice::Int, ::Ice::Int&, ::PT::MatterClsSeq&, const ::Ice::Context*);

    virtual ::Ice::Int PreSend2L3(const ::PT::dtPTCommon&, const ::std::string&, const ::std::string&, const ::std::string&, ::std::string&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int CheckPreSend(const ::PT::dtPTCommon&, const ::std::string&, ::std::string&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int MatInfSearch(const ::PT::dtPTCommon&, const ::std::string&, ::PT::MatterCls&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int MatInfQuery(const ::std::string&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int StockInfSearch(const ::PT::dtPTCommon&, const ::std::string&, ::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int StockInfSumbit(const ::std::string&, const ::PT::dtPTCommon&, const ::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int StockDiffSearch(::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int OutSearch(const ::std::string&, ::PT::LstOutPlan&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int OutInventoryInfo(const ::std::string&, ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int RecheckLIST(const ::std::string&, ::std::string&, ::PT::LstInventoryStocks&, const ::Ice::Context*);

    virtual ::Ice::Int MatInOut(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int MatInOutAckSearch(const ::PT::dtPTCommon&, const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);
};

}

}

namespace IceDelegateD
{

namespace PT
{

class PTInterface : virtual public ::IceDelegate::PT::PTInterface,
                    virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::Ice::Int UsrLoginCheck(const ::PT::dtPTCommon&, const ::std::string&, ::std::string&, ::Ice::Int&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int TruckPos(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::PT::TruckCls&, ::std::string&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int TruckInInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, ::std::string&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int SearchMatInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, ::PT::MatterClsSeq&, ::std::string&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int DeleteWrongMat(const ::PT::TruckCls&, const ::std::string&, ::Ice::Int, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int SubmitTruckInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int TruckInOutAck(const ::PT::dtPTCommon&, ::Ice::Int, ::Ice::Int&, ::PT::MatterClsSeq&, const ::Ice::Context*);

    virtual ::Ice::Int PreSend2L3(const ::PT::dtPTCommon&, const ::std::string&, const ::std::string&, const ::std::string&, ::std::string&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int CheckPreSend(const ::PT::dtPTCommon&, const ::std::string&, ::std::string&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int MatInfSearch(const ::PT::dtPTCommon&, const ::std::string&, ::PT::MatterCls&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int MatInfQuery(const ::std::string&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int StockInfSearch(const ::PT::dtPTCommon&, const ::std::string&, ::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int StockInfSumbit(const ::std::string&, const ::PT::dtPTCommon&, const ::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int StockDiffSearch(::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int OutSearch(const ::std::string&, ::PT::LstOutPlan&, ::Ice::Int&, const ::Ice::Context*);

    virtual ::Ice::Int OutInventoryInfo(const ::std::string&, ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int RecheckLIST(const ::std::string&, ::std::string&, ::PT::LstInventoryStocks&, const ::Ice::Context*);

    virtual ::Ice::Int MatInOut(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int MatInOutAckSearch(const ::PT::dtPTCommon&, const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);
};

}

}

namespace PT
{

class PTInterface : virtual public ::Ice::Object
{
public:

    typedef PTInterfacePrx ProxyType;
    typedef PTInterfacePtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Ice::Int UsrLoginCheck(const ::PT::dtPTCommon&, const ::std::string&, ::std::string&, ::Ice::Int&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___UsrLoginCheck(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int TruckPos(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::PT::TruckCls&, ::std::string&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___TruckPos(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int TruckInInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, ::std::string&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___TruckInInf(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int SearchMatInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, ::PT::MatterClsSeq&, ::std::string&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___SearchMatInf(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int DeleteWrongMat(const ::PT::TruckCls&, const ::std::string&, ::Ice::Int, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___DeleteWrongMat(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int SubmitTruckInf(const ::PT::dtPTCommon&, const ::PT::TruckCls&, ::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___SubmitTruckInf(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int TruckInOutAck(const ::PT::dtPTCommon&, ::Ice::Int, ::Ice::Int&, ::PT::MatterClsSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___TruckInOutAck(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int PreSend2L3(const ::PT::dtPTCommon&, const ::std::string&, const ::std::string&, const ::std::string&, ::std::string&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___PreSend2L3(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int CheckPreSend(const ::PT::dtPTCommon&, const ::std::string&, ::std::string&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___CheckPreSend(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int MatInfSearch(const ::PT::dtPTCommon&, const ::std::string&, ::PT::MatterCls&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___MatInfSearch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int MatInfQuery(const ::std::string&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___MatInfQuery(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int StockInfSearch(const ::PT::dtPTCommon&, const ::std::string&, ::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___StockInfSearch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int StockInfSumbit(const ::std::string&, const ::PT::dtPTCommon&, const ::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___StockInfSumbit(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int StockDiffSearch(::PT::MatterClsSeq&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___StockDiffSearch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int OutSearch(const ::std::string&, ::PT::LstOutPlan&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___OutSearch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int OutInventoryInfo(const ::std::string&, ::std::string&, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___OutInventoryInfo(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int RecheckLIST(const ::std::string&, ::std::string&, ::PT::LstInventoryStocks&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___RecheckLIST(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int MatInOut(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___MatInOut(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int MatInOutAckSearch(const ::PT::dtPTCommon&, const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___MatInOutAckSearch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const PTInterface& l, const PTInterface& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const PTInterface& l, const PTInterface& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace PT
{

template<class T>
class CallbackNC_PTInterface_UsrLoginCheck : public Callback_PTInterface_UsrLoginCheck_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, ::Ice::Int, ::Ice::Int);

    CallbackNC_PTInterface_UsrLoginCheck(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string cID;
        ::Ice::Int nRet;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_UsrLoginCheck(cID, nRet, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, cID, nRet, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, cID, nRet, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_UsrLoginCheckPtr
newCallback_PTInterface_UsrLoginCheck(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_UsrLoginCheck<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_UsrLoginCheckPtr
newCallback_PTInterface_UsrLoginCheck(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_UsrLoginCheck<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_UsrLoginCheck : public Callback_PTInterface_UsrLoginCheck_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, ::Ice::Int, ::Ice::Int, const CT&);

    Callback_PTInterface_UsrLoginCheck(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string cID;
        ::Ice::Int nRet;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_UsrLoginCheck(cID, nRet, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, cID, nRet, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, cID, nRet, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_UsrLoginCheckPtr
newCallback_PTInterface_UsrLoginCheck(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_UsrLoginCheck<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_UsrLoginCheckPtr
newCallback_PTInterface_UsrLoginCheck(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_UsrLoginCheck<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_TruckPos : public Callback_PTInterface_TruckPos_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::PT::TruckCls&, const ::std::string&, ::Ice::Int);

    CallbackNC_PTInterface_TruckPos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::PT::TruckCls Turck;
        ::std::string cID;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_TruckPos(Turck, cID, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, Turck, cID, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, Turck, cID, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_TruckPosPtr
newCallback_PTInterface_TruckPos(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::PT::TruckCls&, const ::std::string&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_TruckPos<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_TruckPosPtr
newCallback_PTInterface_TruckPos(T* instance, void (T::*cb)(::Ice::Int, const ::PT::TruckCls&, const ::std::string&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_TruckPos<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_TruckPos : public Callback_PTInterface_TruckPos_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::PT::TruckCls&, const ::std::string&, ::Ice::Int, const CT&);

    Callback_PTInterface_TruckPos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::PT::TruckCls Turck;
        ::std::string cID;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_TruckPos(Turck, cID, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, Turck, cID, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, Turck, cID, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_TruckPosPtr
newCallback_PTInterface_TruckPos(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::PT::TruckCls&, const ::std::string&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_TruckPos<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_TruckPosPtr
newCallback_PTInterface_TruckPos(T* instance, void (T::*cb)(::Ice::Int, const ::PT::TruckCls&, const ::std::string&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_TruckPos<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_TruckInInf : public Callback_PTInterface_TruckInInf_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, ::Ice::Int);

    CallbackNC_PTInterface_TruckInInf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string cID;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_TruckInInf(cID, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, cID, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, cID, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_TruckInInfPtr
newCallback_PTInterface_TruckInInf(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_TruckInInf<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_TruckInInfPtr
newCallback_PTInterface_TruckInInf(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_TruckInInf<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_TruckInInf : public Callback_PTInterface_TruckInInf_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, ::Ice::Int, const CT&);

    Callback_PTInterface_TruckInInf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string cID;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_TruckInInf(cID, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, cID, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, cID, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_TruckInInfPtr
newCallback_PTInterface_TruckInInf(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_TruckInInf<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_TruckInInfPtr
newCallback_PTInterface_TruckInInf(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_TruckInInf<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_SearchMatInf : public Callback_PTInterface_SearchMatInf_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::PT::MatterClsSeq&, const ::std::string&, ::Ice::Int);

    CallbackNC_PTInterface_SearchMatInf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::PT::MatterClsSeq matlist;
        ::std::string cID;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_SearchMatInf(matlist, cID, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, matlist, cID, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, matlist, cID, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_SearchMatInfPtr
newCallback_PTInterface_SearchMatInf(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::PT::MatterClsSeq&, const ::std::string&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_SearchMatInf<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_SearchMatInfPtr
newCallback_PTInterface_SearchMatInf(T* instance, void (T::*cb)(::Ice::Int, const ::PT::MatterClsSeq&, const ::std::string&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_SearchMatInf<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_SearchMatInf : public Callback_PTInterface_SearchMatInf_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::PT::MatterClsSeq&, const ::std::string&, ::Ice::Int, const CT&);

    Callback_PTInterface_SearchMatInf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::PT::MatterClsSeq matlist;
        ::std::string cID;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_SearchMatInf(matlist, cID, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, matlist, cID, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, matlist, cID, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_SearchMatInfPtr
newCallback_PTInterface_SearchMatInf(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::PT::MatterClsSeq&, const ::std::string&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_SearchMatInf<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_SearchMatInfPtr
newCallback_PTInterface_SearchMatInf(T* instance, void (T::*cb)(::Ice::Int, const ::PT::MatterClsSeq&, const ::std::string&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_SearchMatInf<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_DeleteWrongMat : public Callback_PTInterface_DeleteWrongMat_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int);

    CallbackNC_PTInterface_DeleteWrongMat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_DeleteWrongMat(nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_DeleteWrongMatPtr
newCallback_PTInterface_DeleteWrongMat(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_DeleteWrongMat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_DeleteWrongMatPtr
newCallback_PTInterface_DeleteWrongMat(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_DeleteWrongMat<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_DeleteWrongMat : public Callback_PTInterface_DeleteWrongMat_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int, const CT&);

    Callback_PTInterface_DeleteWrongMat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_DeleteWrongMat(nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_DeleteWrongMatPtr
newCallback_PTInterface_DeleteWrongMat(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_DeleteWrongMat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_DeleteWrongMatPtr
newCallback_PTInterface_DeleteWrongMat(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_DeleteWrongMat<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_SubmitTruckInf : public Callback_PTInterface_SubmitTruckInf_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int);

    CallbackNC_PTInterface_SubmitTruckInf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_SubmitTruckInf(nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_SubmitTruckInfPtr
newCallback_PTInterface_SubmitTruckInf(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_SubmitTruckInf<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_SubmitTruckInfPtr
newCallback_PTInterface_SubmitTruckInf(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_SubmitTruckInf<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_SubmitTruckInf : public Callback_PTInterface_SubmitTruckInf_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int, const CT&);

    Callback_PTInterface_SubmitTruckInf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_SubmitTruckInf(nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_SubmitTruckInfPtr
newCallback_PTInterface_SubmitTruckInf(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_SubmitTruckInf<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_SubmitTruckInfPtr
newCallback_PTInterface_SubmitTruckInf(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_SubmitTruckInf<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_TruckInOutAck : public Callback_PTInterface_TruckInOutAck_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int, const ::PT::MatterClsSeq&);

    CallbackNC_PTInterface_TruckInOutAck(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int nResult;
        ::PT::MatterClsSeq matlist;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_TruckInOutAck(nResult, matlist, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nResult, matlist);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, nResult, matlist);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_TruckInOutAckPtr
newCallback_PTInterface_TruckInOutAck(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const ::PT::MatterClsSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_TruckInOutAck<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_TruckInOutAckPtr
newCallback_PTInterface_TruckInOutAck(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const ::PT::MatterClsSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_TruckInOutAck<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_TruckInOutAck : public Callback_PTInterface_TruckInOutAck_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int, const ::PT::MatterClsSeq&, const CT&);

    Callback_PTInterface_TruckInOutAck(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int nResult;
        ::PT::MatterClsSeq matlist;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_TruckInOutAck(nResult, matlist, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nResult, matlist, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, nResult, matlist, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_TruckInOutAckPtr
newCallback_PTInterface_TruckInOutAck(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const ::PT::MatterClsSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_TruckInOutAck<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_TruckInOutAckPtr
newCallback_PTInterface_TruckInOutAck(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const ::PT::MatterClsSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_TruckInOutAck<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_PreSend2L3 : public Callback_PTInterface_PreSend2L3_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, ::Ice::Int);

    CallbackNC_PTInterface_PreSend2L3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string cID;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_PreSend2L3(cID, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, cID, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, cID, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_PreSend2L3Ptr
newCallback_PTInterface_PreSend2L3(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_PreSend2L3<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_PreSend2L3Ptr
newCallback_PTInterface_PreSend2L3(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_PreSend2L3<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_PreSend2L3 : public Callback_PTInterface_PreSend2L3_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, ::Ice::Int, const CT&);

    Callback_PTInterface_PreSend2L3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string cID;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_PreSend2L3(cID, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, cID, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, cID, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_PreSend2L3Ptr
newCallback_PTInterface_PreSend2L3(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_PreSend2L3<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_PreSend2L3Ptr
newCallback_PTInterface_PreSend2L3(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_PreSend2L3<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_CheckPreSend : public Callback_PTInterface_CheckPreSend_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, ::Ice::Int);

    CallbackNC_PTInterface_CheckPreSend(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string cRetMessage;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_CheckPreSend(cRetMessage, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, cRetMessage, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, cRetMessage, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_CheckPreSendPtr
newCallback_PTInterface_CheckPreSend(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_CheckPreSend<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_CheckPreSendPtr
newCallback_PTInterface_CheckPreSend(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_CheckPreSend<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_CheckPreSend : public Callback_PTInterface_CheckPreSend_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, ::Ice::Int, const CT&);

    Callback_PTInterface_CheckPreSend(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string cRetMessage;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_CheckPreSend(cRetMessage, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, cRetMessage, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, cRetMessage, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_CheckPreSendPtr
newCallback_PTInterface_CheckPreSend(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_CheckPreSend<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_CheckPreSendPtr
newCallback_PTInterface_CheckPreSend(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_CheckPreSend<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_MatInfSearch : public Callback_PTInterface_MatInfSearch_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::PT::MatterCls&, ::Ice::Int);

    CallbackNC_PTInterface_MatInfSearch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::PT::MatterCls mat;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_MatInfSearch(mat, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, mat, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, mat, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_MatInfSearchPtr
newCallback_PTInterface_MatInfSearch(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::PT::MatterCls&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_MatInfSearch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_MatInfSearchPtr
newCallback_PTInterface_MatInfSearch(T* instance, void (T::*cb)(::Ice::Int, const ::PT::MatterCls&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_MatInfSearch<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_MatInfSearch : public Callback_PTInterface_MatInfSearch_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::PT::MatterCls&, ::Ice::Int, const CT&);

    Callback_PTInterface_MatInfSearch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::PT::MatterCls mat;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_MatInfSearch(mat, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, mat, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, mat, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_MatInfSearchPtr
newCallback_PTInterface_MatInfSearch(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::PT::MatterCls&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_MatInfSearch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_MatInfSearchPtr
newCallback_PTInterface_MatInfSearch(T* instance, void (T::*cb)(::Ice::Int, const ::PT::MatterCls&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_MatInfSearch<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_MatInfQuery : public Callback_PTInterface_MatInfQuery_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int);

    CallbackNC_PTInterface_MatInfQuery(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_MatInfQuery(nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_MatInfQueryPtr
newCallback_PTInterface_MatInfQuery(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_MatInfQuery<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_MatInfQueryPtr
newCallback_PTInterface_MatInfQuery(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_MatInfQuery<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_MatInfQuery : public Callback_PTInterface_MatInfQuery_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int, const CT&);

    Callback_PTInterface_MatInfQuery(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_MatInfQuery(nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_MatInfQueryPtr
newCallback_PTInterface_MatInfQuery(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_MatInfQuery<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_MatInfQueryPtr
newCallback_PTInterface_MatInfQuery(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_MatInfQuery<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_StockInfSearch : public Callback_PTInterface_StockInfSearch_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int);

    CallbackNC_PTInterface_StockInfSearch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::PT::MatterClsSeq mat;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StockInfSearch(mat, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, mat, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, mat, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_StockInfSearchPtr
newCallback_PTInterface_StockInfSearch(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_StockInfSearch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_StockInfSearchPtr
newCallback_PTInterface_StockInfSearch(T* instance, void (T::*cb)(::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_StockInfSearch<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_StockInfSearch : public Callback_PTInterface_StockInfSearch_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int, const CT&);

    Callback_PTInterface_StockInfSearch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::PT::MatterClsSeq mat;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StockInfSearch(mat, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, mat, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, mat, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_StockInfSearchPtr
newCallback_PTInterface_StockInfSearch(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_StockInfSearch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_StockInfSearchPtr
newCallback_PTInterface_StockInfSearch(T* instance, void (T::*cb)(::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_StockInfSearch<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_StockInfSumbit : public Callback_PTInterface_StockInfSumbit_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int);

    CallbackNC_PTInterface_StockInfSumbit(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StockInfSumbit(nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_StockInfSumbitPtr
newCallback_PTInterface_StockInfSumbit(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_StockInfSumbit<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_StockInfSumbitPtr
newCallback_PTInterface_StockInfSumbit(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_StockInfSumbit<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_StockInfSumbit : public Callback_PTInterface_StockInfSumbit_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int, const CT&);

    Callback_PTInterface_StockInfSumbit(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StockInfSumbit(nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_StockInfSumbitPtr
newCallback_PTInterface_StockInfSumbit(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_StockInfSumbit<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_StockInfSumbitPtr
newCallback_PTInterface_StockInfSumbit(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_StockInfSumbit<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_StockDiffSearch : public Callback_PTInterface_StockDiffSearch_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int);

    CallbackNC_PTInterface_StockDiffSearch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::PT::MatterClsSeq mat;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StockDiffSearch(mat, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, mat, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, mat, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_StockDiffSearchPtr
newCallback_PTInterface_StockDiffSearch(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_StockDiffSearch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_StockDiffSearchPtr
newCallback_PTInterface_StockDiffSearch(T* instance, void (T::*cb)(::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_StockDiffSearch<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_StockDiffSearch : public Callback_PTInterface_StockDiffSearch_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int, const CT&);

    Callback_PTInterface_StockDiffSearch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::PT::MatterClsSeq mat;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StockDiffSearch(mat, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, mat, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, mat, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_StockDiffSearchPtr
newCallback_PTInterface_StockDiffSearch(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_StockDiffSearch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_StockDiffSearchPtr
newCallback_PTInterface_StockDiffSearch(T* instance, void (T::*cb)(::Ice::Int, const ::PT::MatterClsSeq&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_StockDiffSearch<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_OutSearch : public Callback_PTInterface_OutSearch_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::PT::LstOutPlan&, ::Ice::Int);

    CallbackNC_PTInterface_OutSearch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::PT::LstOutPlan matlist;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_OutSearch(matlist, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, matlist, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, matlist, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_OutSearchPtr
newCallback_PTInterface_OutSearch(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::PT::LstOutPlan&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_OutSearch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_OutSearchPtr
newCallback_PTInterface_OutSearch(T* instance, void (T::*cb)(::Ice::Int, const ::PT::LstOutPlan&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_OutSearch<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_OutSearch : public Callback_PTInterface_OutSearch_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::PT::LstOutPlan&, ::Ice::Int, const CT&);

    Callback_PTInterface_OutSearch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::PT::LstOutPlan matlist;
        ::Ice::Int nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_OutSearch(matlist, nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, matlist, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, matlist, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_OutSearchPtr
newCallback_PTInterface_OutSearch(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::PT::LstOutPlan&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_OutSearch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_OutSearchPtr
newCallback_PTInterface_OutSearch(T* instance, void (T::*cb)(::Ice::Int, const ::PT::LstOutPlan&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_OutSearch<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_OutInventoryInfo : public Callback_PTInterface_OutInventoryInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const ::std::string&);

    CallbackNC_PTInterface_OutInventoryInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string id;
        ::std::string area;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_OutInventoryInfo(id, area, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, id, area);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, id, area);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_OutInventoryInfoPtr
newCallback_PTInterface_OutInventoryInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_OutInventoryInfo<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_OutInventoryInfoPtr
newCallback_PTInterface_OutInventoryInfo(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_OutInventoryInfo<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_OutInventoryInfo : public Callback_PTInterface_OutInventoryInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const ::std::string&, const CT&);

    Callback_PTInterface_OutInventoryInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string id;
        ::std::string area;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_OutInventoryInfo(id, area, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, id, area, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, id, area, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_OutInventoryInfoPtr
newCallback_PTInterface_OutInventoryInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_OutInventoryInfo<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_OutInventoryInfoPtr
newCallback_PTInterface_OutInventoryInfo(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_OutInventoryInfo<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_RecheckLIST : public Callback_PTInterface_RecheckLIST_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const ::PT::LstInventoryStocks&);

    CallbackNC_PTInterface_RecheckLIST(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string id;
        ::PT::LstInventoryStocks LIST;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_RecheckLIST(id, LIST, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, id, LIST);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, id, LIST);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_RecheckLISTPtr
newCallback_PTInterface_RecheckLIST(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::PT::LstInventoryStocks&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_RecheckLIST<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_RecheckLISTPtr
newCallback_PTInterface_RecheckLIST(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::PT::LstInventoryStocks&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_RecheckLIST<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_RecheckLIST : public Callback_PTInterface_RecheckLIST_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const ::PT::LstInventoryStocks&, const CT&);

    Callback_PTInterface_RecheckLIST(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string id;
        ::PT::LstInventoryStocks LIST;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_RecheckLIST(id, LIST, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, id, LIST, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, id, LIST, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_RecheckLISTPtr
newCallback_PTInterface_RecheckLIST(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::PT::LstInventoryStocks&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_RecheckLIST<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_RecheckLISTPtr
newCallback_PTInterface_RecheckLIST(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::PT::LstInventoryStocks&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_RecheckLIST<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_MatInOut : public Callback_PTInterface_MatInOut_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&);

    CallbackNC_PTInterface_MatInOut(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_MatInOut(nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_MatInOutPtr
newCallback_PTInterface_MatInOut(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_MatInOut<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_MatInOutPtr
newCallback_PTInterface_MatInOut(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_MatInOut<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_MatInOut : public Callback_PTInterface_MatInOut_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const CT&);

    Callback_PTInterface_MatInOut(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_MatInOut(nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_MatInOutPtr
newCallback_PTInterface_MatInOut(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_MatInOut<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_MatInOutPtr
newCallback_PTInterface_MatInOut(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_MatInOut<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PTInterface_MatInOutAckSearch : public Callback_PTInterface_MatInOutAckSearch_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&);

    CallbackNC_PTInterface_MatInOutAckSearch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_MatInOutAckSearch(nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nResult);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, nResult);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PTInterface_MatInOutAckSearchPtr
newCallback_PTInterface_MatInOutAckSearch(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_MatInOutAckSearch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PTInterface_MatInOutAckSearchPtr
newCallback_PTInterface_MatInOutAckSearch(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PTInterface_MatInOutAckSearch<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PTInterface_MatInOutAckSearch : public Callback_PTInterface_MatInOutAckSearch_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const CT&);

    Callback_PTInterface_MatInOutAckSearch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::PT::PTInterfacePrx __proxy = ::PT::PTInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string nResult;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_MatInOutAckSearch(nResult, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nResult, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, nResult, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PTInterface_MatInOutAckSearchPtr
newCallback_PTInterface_MatInOutAckSearch(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_MatInOutAckSearch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PTInterface_MatInOutAckSearchPtr
newCallback_PTInterface_MatInOutAckSearch(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PTInterface_MatInOutAckSearch<T, CT>(instance, cb, excb, sentcb);
}

}

#endif
