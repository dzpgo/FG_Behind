// **********************************************************************
//
// Copyright (c) 2003-2010 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

// Ice version 3.4.1

// <auto-generated>
//
// Generated from file `LineL2Plan.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#ifndef ___________include_clts_slice_LineL2Plan_h__
#define ___________include_clts_slice_LineL2Plan_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/StreamF.h>
#include <CltsException.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace CLTS
{

struct LineL2PlanDesc
{
    ::std::string unitNo;
    ::Ice::Int seq;
    ::std::string planNo;
    ::std::string coilNo;
    ::Ice::Int weight;
    ::Ice::Int width;
    ::Ice::Int inDia;
    ::Ice::Int outDia;
    ::std::string packFlag;
    ::Ice::Int sleeveWidth;
    ::Ice::Int coilDirection;
    ::std::string alarmCode;
    ::std::string status;

    bool operator==(const LineL2PlanDesc& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(unitNo != __rhs.unitNo)
        {
            return false;
        }
        if(seq != __rhs.seq)
        {
            return false;
        }
        if(planNo != __rhs.planNo)
        {
            return false;
        }
        if(coilNo != __rhs.coilNo)
        {
            return false;
        }
        if(weight != __rhs.weight)
        {
            return false;
        }
        if(width != __rhs.width)
        {
            return false;
        }
        if(inDia != __rhs.inDia)
        {
            return false;
        }
        if(outDia != __rhs.outDia)
        {
            return false;
        }
        if(packFlag != __rhs.packFlag)
        {
            return false;
        }
        if(sleeveWidth != __rhs.sleeveWidth)
        {
            return false;
        }
        if(coilDirection != __rhs.coilDirection)
        {
            return false;
        }
        if(alarmCode != __rhs.alarmCode)
        {
            return false;
        }
        if(status != __rhs.status)
        {
            return false;
        }
        return true;
    }

    bool operator<(const LineL2PlanDesc& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(unitNo < __rhs.unitNo)
        {
            return true;
        }
        else if(__rhs.unitNo < unitNo)
        {
            return false;
        }
        if(seq < __rhs.seq)
        {
            return true;
        }
        else if(__rhs.seq < seq)
        {
            return false;
        }
        if(planNo < __rhs.planNo)
        {
            return true;
        }
        else if(__rhs.planNo < planNo)
        {
            return false;
        }
        if(coilNo < __rhs.coilNo)
        {
            return true;
        }
        else if(__rhs.coilNo < coilNo)
        {
            return false;
        }
        if(weight < __rhs.weight)
        {
            return true;
        }
        else if(__rhs.weight < weight)
        {
            return false;
        }
        if(width < __rhs.width)
        {
            return true;
        }
        else if(__rhs.width < width)
        {
            return false;
        }
        if(inDia < __rhs.inDia)
        {
            return true;
        }
        else if(__rhs.inDia < inDia)
        {
            return false;
        }
        if(outDia < __rhs.outDia)
        {
            return true;
        }
        else if(__rhs.outDia < outDia)
        {
            return false;
        }
        if(packFlag < __rhs.packFlag)
        {
            return true;
        }
        else if(__rhs.packFlag < packFlag)
        {
            return false;
        }
        if(sleeveWidth < __rhs.sleeveWidth)
        {
            return true;
        }
        else if(__rhs.sleeveWidth < sleeveWidth)
        {
            return false;
        }
        if(coilDirection < __rhs.coilDirection)
        {
            return true;
        }
        else if(__rhs.coilDirection < coilDirection)
        {
            return false;
        }
        if(alarmCode < __rhs.alarmCode)
        {
            return true;
        }
        else if(__rhs.alarmCode < alarmCode)
        {
            return false;
        }
        if(status < __rhs.status)
        {
            return true;
        }
        else if(__rhs.status < status)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const LineL2PlanDesc& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const LineL2PlanDesc& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const LineL2PlanDesc& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const LineL2PlanDesc& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::CLTS::LineL2PlanDesc> LineL2PlanDescSeq;
void __writeLineL2PlanDescSeq(::IceInternal::BasicStream*, const ::CLTS::LineL2PlanDesc*, const ::CLTS::LineL2PlanDesc*);
void __readLineL2PlanDescSeq(::IceInternal::BasicStream*, LineL2PlanDescSeq&);

struct LineRejCoilDesc
{
    ::std::string unitNo;
    ::std::string saddleL2Name;
    ::std::string coilNo;
    ::Ice::Int weight;
    ::Ice::Int width;
    ::Ice::Int inDia;
    ::Ice::Int outDia;
    ::Ice::Int sleeveWidth;
    ::Ice::Int coilOpenDirection;
    ::std::string alarmCode;
    ::std::string nextUnitNo;

    bool operator==(const LineRejCoilDesc& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(unitNo != __rhs.unitNo)
        {
            return false;
        }
        if(saddleL2Name != __rhs.saddleL2Name)
        {
            return false;
        }
        if(coilNo != __rhs.coilNo)
        {
            return false;
        }
        if(weight != __rhs.weight)
        {
            return false;
        }
        if(width != __rhs.width)
        {
            return false;
        }
        if(inDia != __rhs.inDia)
        {
            return false;
        }
        if(outDia != __rhs.outDia)
        {
            return false;
        }
        if(sleeveWidth != __rhs.sleeveWidth)
        {
            return false;
        }
        if(coilOpenDirection != __rhs.coilOpenDirection)
        {
            return false;
        }
        if(alarmCode != __rhs.alarmCode)
        {
            return false;
        }
        if(nextUnitNo != __rhs.nextUnitNo)
        {
            return false;
        }
        return true;
    }

    bool operator<(const LineRejCoilDesc& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(unitNo < __rhs.unitNo)
        {
            return true;
        }
        else if(__rhs.unitNo < unitNo)
        {
            return false;
        }
        if(saddleL2Name < __rhs.saddleL2Name)
        {
            return true;
        }
        else if(__rhs.saddleL2Name < saddleL2Name)
        {
            return false;
        }
        if(coilNo < __rhs.coilNo)
        {
            return true;
        }
        else if(__rhs.coilNo < coilNo)
        {
            return false;
        }
        if(weight < __rhs.weight)
        {
            return true;
        }
        else if(__rhs.weight < weight)
        {
            return false;
        }
        if(width < __rhs.width)
        {
            return true;
        }
        else if(__rhs.width < width)
        {
            return false;
        }
        if(inDia < __rhs.inDia)
        {
            return true;
        }
        else if(__rhs.inDia < inDia)
        {
            return false;
        }
        if(outDia < __rhs.outDia)
        {
            return true;
        }
        else if(__rhs.outDia < outDia)
        {
            return false;
        }
        if(sleeveWidth < __rhs.sleeveWidth)
        {
            return true;
        }
        else if(__rhs.sleeveWidth < sleeveWidth)
        {
            return false;
        }
        if(coilOpenDirection < __rhs.coilOpenDirection)
        {
            return true;
        }
        else if(__rhs.coilOpenDirection < coilOpenDirection)
        {
            return false;
        }
        if(alarmCode < __rhs.alarmCode)
        {
            return true;
        }
        else if(__rhs.alarmCode < alarmCode)
        {
            return false;
        }
        if(nextUnitNo < __rhs.nextUnitNo)
        {
            return true;
        }
        else if(__rhs.nextUnitNo < nextUnitNo)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const LineRejCoilDesc& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const LineRejCoilDesc& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const LineRejCoilDesc& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const LineRejCoilDesc& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::CLTS::LineRejCoilDesc> LineRejCoilDescSeq;
void __writeLineRejCoilDescSeq(::IceInternal::BasicStream*, const ::CLTS::LineRejCoilDesc*, const ::CLTS::LineRejCoilDesc*);
void __readLineRejCoilDescSeq(::IceInternal::BasicStream*, LineRejCoilDescSeq&);

}

#endif
